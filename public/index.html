<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>聊天室</title>
<style>
  :root {
    --sunset-yellow: #FFD54F;
    --light-red: #FF8A80;
    --warm-orange: #FFB74D;
    --cool-teal: #4DB6AC;
    --light-purple: #BA68C8;
    --light-pink: #F48FB1;
  }
  body {
    margin: 0;
    font-family: sans-serif;
    background: linear-gradient(135deg, var(--sunset-yellow) 0%, var(--light-red) 20%, var(--warm-orange) 40%, var(--cool-teal) 60%, var(--light-purple) 80%, var(--light-pink) 100%);
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255,255,255,0.2);
    padding: 10px;
    color: #fff;
    font-weight: bold;
    backdrop-filter: blur(5px);
  }
  .top-center {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .top-center img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }
  .top-bar button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
  }
  #log {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }
  .msg {
    max-width: 70%;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 12px;
    color: #000;
    background: rgba(255,255,255,0.8);
    word-wrap: break-word;
  }
  .me { background: #DCF8C6; align-self: flex-end; }
  .other { background: rgba(255,255,255,0.6); align-self: flex-start; }
  .system { background: rgba(200,200,200,0.7); text-align: center; color: #000; }
  .input-area {
    display: flex;
    padding: 10px;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(5px);
    position: relative;
  }
  #msg { flex: 1; padding: 8px; border: none; border-radius: 20px; outline: none; }
  #sendBtn, #emojiBtn { margin-left: 5px; padding: 8px 12px; border: none; border-radius: 20px; cursor: pointer; background: rgba(255,255,255,0.9); }

  /* 表情面板 */
  #emojiPanel {
    position: absolute;
    bottom: 50px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    border-radius: 8px;
    padding: 5px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  #emojiPanel button {
    font-size: 20px;
    border: none;
    background: none;
    cursor: pointer;
  }
  <style>
  /* 状态样式 */
  .status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 14px;
    color: #fff;
  }
  .status-circle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: breathe 2s infinite ease-in-out;
  }

  @keyframes breathe {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.6; }
  }

  /* 根据不同状态动态修改颜色和动画时间 */
  .online { background: green; animation-duration: 2s; }
  .offline { background: gray; animation-duration: 10s; }
  .busy { background: yellow; animation-duration: 15s; }
</style>
</head>
<body>

<div class="top-bar">
  <button onclick="window.location.href='/'">🏠</button>
  <div class="top-center">
    <img id="partnerAvatar" src="/image/f64be2438709ee1f11ad8754e282b1df.jpeg" alt="对方头像">
    <span id="partnerName">未知用户</span>
    <div id="partnerStatus" class="status">
      <div id="statusCircle" class="status-circle offline"></div>
      <span id="statusText">离线</span>
  </div>
  </div>
  <button onclick="startCall()">📞</button>
</div>

<div id="log"></div>

<div class="input-area">
  <input id="msg" placeholder="输入消息..." />
  <button id="emojiBtn" onclick="toggleEmojiPanel()">😊</button>
  <button id="sendBtn" onclick="send()" disabled>发送</button>
</div>
<script>
function setPartnerStatus(state){
  const circle = document.getElementById("statusCircle");
  const text = document.getElementById("statusText");
  circle.className = "status-circle " + state;
  if(state === "online") text.textContent = "在线";
  if(state === "offline") text.textContent = "离线";
  if(state === "busy") text.textContent = "繁忙";
    partnerInfo.state = state;
}
  
</script> 
<script type="module">
  import { schnorr } from "https://esm.sh/@noble/curves/secp256k1";
  import { sha256 } from "https://esm.sh/@noble/hashes/sha256";

  // 工具函数：Uint8Array → hex
  function toHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }

  // 生成私钥、公钥
  const priv = schnorr.utils.randomPrivateKey();
  const pub = schnorr.getPublicKey(priv);

  // 挂到全局，后面 send() 用
  window.myPrivKey = priv;
  window.myPubKey = toHex(pub);
  window.nobleSchnorr = schnorr;
  console.log("pubkey:", window.myPubKey);
  // === 生成凭证 ===
async function generateCredential() {
  const now = Math.floor(Date.now() / 1000); // 秒级时间戳
  const expireAt = now + 7 * 24 * 60 * 60; // +7天

  const payload = {
    pubkey: window.myPubKey,
    issuedAt: now,
    expireAt: expireAt
  };

  // 对 payload 做哈希
  const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
  const id = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");

  // 用 schnorr 签名
  const sig = await schnorr.sign(id, window.myPrivKey);

  const credential = {
    ...payload,
    id,
    sig: toHex(sig)
  };

  window.credential = credential; // 挂到全局
  console.log("凭证生成:", credential);
}
generateCredential();
</script>

<script>
 function toHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }
window.username = "";   
window.onload = () => {
  let name = "";
  do {
    name = prompt("请输入你的昵称:");
  } while(!name || name.trim() === "");
  window.username = name;  
};
const partnerAvatar = document.getElementById("partnerAvatar");
const partnerName = document.getElementById("partnerName");
const logDiv = document.getElementById("log");
const socket = new WebSocket("wss://relay.damus.io");

let myRoom = null;
let partnerInfo = { username: "未知用户", avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg", online: false };
let emojis = [];
const myUsersMap = {}; // pubkey → 用户名映射
// -------------------- 表情包 --------------------
fetch('other/emojis.json')
  .then(res => res.json())
  .then(data => emojis = data);

function toggleEmojiPanel(){
  let panel = document.getElementById('emojiPanel');
  if(panel) { panel.remove(); return; }

  panel = document.createElement('div');
  panel.id = 'emojiPanel';
  emojis.forEach(e=>{
    const btn = document.createElement('button');
    btn.innerText = e.symbol;
    btn.onclick = ()=> insertEmoji(e.symbol);
    panel.appendChild(btn);
  });
  document.querySelector('.input-area').appendChild(panel);
}

function insertEmoji(symbol){
  const msgInput = document.getElementById("msg");
  msgInput.value += symbol;
  msgInput.focus();
}
async function send(eventobj=null) {
 if(!eventobj){
   const msgInput = document.getElementById("msg");
   const msg = msgInput.value.trim();
   if (!msg) return;
   if(socket.readyState === WebSocket.OPEN){
   const eventobj = {
    pubkey: window.myPubKey,
    created_at: Math.floor(Date.now() / 1000),
    kind: 1,
    tags: [["t", "room10008"]],   // 指定聊天室标签
    content: msg
    };

   // 计算 id
   const payload = [0, eventobj.pubkey, eventobj.created_at, eventobj.kind, eventobj.tags, eventobj.content];
   const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
   eventobj.id = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
  // 签名
   const sig = await nobleSchnorr.sign(eventobj.id, window.myPrivKey);
   eventobj.sig = toHex(sig);
  // 发送
    socket.send(JSON.stringify(["EVENT", eventobj]));
    if(!eventobj.tags.some(t=>t[0]==="t")){
      document.getElementById("msg").value = "";
       log(`${msg}`, "me"); 
    }
  }  else {
    log("⚠️ 连接尚未建立或房间未分配", "system");
  }
 }
 }
// -------------------- 聊天功能 --------------------
let participants = [];
socket.onopen = () => {
  log("✅ 已连接Relay网络聊天室", "system");
  setPartnerStatus("online")//加入聊天室后，默认在线状态
  document.getElementById("sendBtn").disabled = false;
  //socket.send(JSON.stringify({ system: true, join: true, username, avatar: "", requestRoom: true }));
  socket.send(
    JSON.stringify(
      [
        "REQ", 
        "sub1",
        { 
          kinds:[1],
          "#t": ["room10008"] 
        }
      ]
    )
  );
  // 发一条 system join 消息
  const joinEvent = {
    pubkey: window.myPubKey,
    created_at: Math.floor(Date.now() / 1000),
    kind: 1,
    tags: [["t", "room10008"]],
    content:`${window.username} 加入了聊天室`
  };
  myUsersMap[window.myPubKey] = window.username; // 保存映射
  send(joinEvent);
};
socket.onmessage = async (e) => {
  try {
    const data = JSON.parse(e.data);
     console.log("收到:", e.data); //日志
     // 处理 OK 消息
    if (Array.isArray(data) && data[0] === "OK") {
      console.log("Relay确认:", data);
      return;
    }
    // 忽略 EOSE
    if (Array.isArray(data) && data[0] === "EOSE") {
      console.log("EOSE 收到:", data[1]);
      return;
    }
  // Relay 推送的 EVENT
  if(Array.isArray(data) && data[0] === "EVENT"){
    const event = data[2];
     if(!event) return;
      // 如果是新 pubkey，尝试从 content 提取用户名
      if (!myUsersMap[event.pubkey]) {
        const match = event.content.match(/^(.+) 加入了聊天室$/);
        if (match) {
          myUsersMap[event.pubkey] = match[1];
        }
      }

      // 显示加入房间事件
      if (event.content.includes("加入了聊天室")) {
        const joinedName = myUsersMap[event.pubkey] || "未知用户";
        log(`${joinedName} 已加入房间`, "system");
        return; // 避免重复显示普通消息
      }
   // 普通消息
      const type = event.pubkey === window.myPubKey ? "me" : "other";
      const name = type === "me" ? window.username : event.pubkey.slice(0, 8);
      log(`${event.content}`, type);
      return;
  }
// system 消息（非 Array）
    if (data.system) {
         log(data.msg, "system");
         return;
     }
        if (type === "other") {
          partnerInfo.pubkey = event.pubkey;
          partnerInfo.username = partnerInfo.username || "未知用户";
          partnerInfo.online = true;
          partnerName.textContent = partnerInfo.username;
          partnerAvatar.src = partnerInfo.avatar || partnerAvatar.src;
        }
      if (event.tags.some(t => t[0] === "t" && t[1] === "room10008")) {
        // 维护 participants 列表
        if (!participants.includes(event.pubkey)) {
          participants.push(event.pubkey);
          console.log("当前参与者:", participants);
        }
        // 判断身份（按先后顺序）
        const type = (event.pubkey === window.myPubKey) ? "me" : "other";
        log(`${event.content}`, type);
      }

    if (data.join && data.username !== window.username) {
      partnerInfo.username = data.username;
      partnerInfo.avatar = data.avatar || partnerInfo.avatar;
      partnerInfo.online = true;
      partnerName.textContent = partnerInfo.username;
      partnerAvatar.src = partnerInfo.avatar;
      log(`${partnerInfo.username} 已加入房间`, "system");

      if (data.join && data.username === window.username) {
        log("等待其他人加入...", "system");
      }
    } else if (data.username && data.msg) {
      const type = data.pubkey === window.myPubKey ? "me" : "other";
      const name = data.username || "未知用户";
      log(`${name}: ${data.msg}`, type);
      if (data.username !== window.username) {
        partnerInfo.username = data.username;
        partnerInfo.avatar = data.avatar || partnerAvatar.src;
        partnerInfo.online = true;
        partnerName.textContent = partnerInfo.username;
        partnerAvatar.src = partnerInfo.avatar;
      }
    } else if (data.type === 'offer' && !isCalling) {
      window.incomingOffer = data.offer;
      partnerInfo.username = data.username;
      partnerName.textContent = partnerInfo.username;
      partnerAvatar.src = data.avatar || partnerAvatar.src;
      startCall(true); // 被叫
    } else if (data.type === 'answer') {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
    } else if (data.type === 'ice' && data.candidate) {
      if (peerConnection) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    }
  } catch(err) {
    console.error("解析失败", e.data, err);
    log("解析失败: " + e.data, "system");
  }
socket.onerror = () => log("❌ 连接出错", "system");
}  
  

function log(message, type="other"){
  const logDiv = document.getElementById("log");
  if(!logDiv) return; 
  const msgDiv = document.createElement("div");
  msgDiv.className = `msg ${type}`;
  msgDiv.textContent = message;
  logDiv.appendChild(msgDiv);
  logDiv.scrollTop = logDiv.scrollHeight;
}

// -------------------- WebRTC语音通话 --------------------
let localStream, peerConnection, isCalling = false;
const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

function startCall(isIncoming=false){
  if(isCalling) return;
  const now=Math.floor(Date.now()/1000)//时间
  if (!window.credential || now > window.credential.expireAt) {
    alert("凭证已过期，请重新进入聊天室");
    return;
  }

  if(!partnerInfo.online){ alert("对方不在线，无法通话"); return; }
  isCalling = true;

  const callOverlay = document.createElement('div');
  callOverlay.id = 'callOverlay';
  Object.assign(callOverlay.style,{
    position:'fixed',top:0,left:0,width:'100%',height:'100%',
    background:'rgba(255,255,255,0.2)',backdropFilter:'blur(10px)',
    display:'flex',flexDirection:'column',justifyContent:'center',alignItems:'center',
    zIndex:9999
  });

  const status = document.createElement('div');
  status.id = 'callStatus';
  status.innerText = isIncoming 
  ? `${partnerInfo.username} 来电` 
  : '正在等待对方接听...';
  Object.assign(status.style,{marginBottom:'20px',color:'#fff',fontSize:'20px'});
  callOverlay.appendChild(status);

  const audio = document.createElement('audio');
  audio.src = 'sound/DaDaDum - The Soundlings.mp3';
  audio.loop = true;
  audio.autoplay = true;
  callOverlay.appendChild(audio);

  const hangupBtn = document.createElement('button');
  hangupBtn.innerText = '📞挂断';
  Object.assign(hangupBtn.style,{background:'red',color:'#fff',marginRight:'20px',padding:'10px 20px'});
  hangupBtn.onclick = () => endCall(true);

  const acceptBtn = document.createElement('button');
  acceptBtn.innerText = '📞接听';
  Object.assign(acceptBtn.style,{background:'green',color:'#fff',padding:'10px 20px'});
  acceptBtn.onclick = acceptCall;

  const btnContainer = document.createElement('div');
  btnContainer.style.display = 'flex';
  btnContainer.style.gap = '20px';
  if(isIncoming) btnContainer.appendChild(acceptBtn);
  btnContainer.appendChild(hangupBtn);
  callOverlay.appendChild(btnContainer);

  document.body.appendChild(callOverlay);

  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    localStream = stream;
    peerConnection = new RTCPeerConnection(config);
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    peerConnection.ontrack = e => {
      let remoteAudio = document.getElementById('remoteAudio');
      if(!remoteAudio){
        remoteAudio = document.createElement('audio');
        remoteAudio.id = 'remoteAudio';
        remoteAudio.autoplay = true;
        document.body.appendChild(remoteAudio);
      }
      remoteAudio.srcObject = e.streams[0];
    };

    peerConnection.onicecandidate = e => {
      if(e.candidate){
        socket.send(JSON.stringify({ type:'ice', candidate:e.candidate, to: partnerInfo.username }));
      }
    };

    if(!isIncoming){
      peerConnection.createOffer().then(offer => {
        peerConnection.setLocalDescription(offer);
        socket.send(JSON.stringify({ type:'offer', offer, to: partnerInfo.username, username, avatar:'' }));
      });
    }
  });
}

function acceptCall(){
  const callStatus = document.getElementById('callStatus');
  callStatus.innerText = '已接听，正在建立通话...';
  document.querySelector('#callOverlay audio').pause();

  peerConnection.setRemoteDescription(new RTCSessionDescription(window.incomingOffer)).then(()=>{
    peerConnection.createAnswer().then(answer=>{
      peerConnection.setLocalDescription(answer);
      socket.send(JSON.stringify({ type:'answer', answer, to: partnerInfo.username }));
    });
  });
}

function endCall(isCaller=false){
  if(peerConnection) peerConnection.close();
  if(localStream) localStream.getTracks().forEach(track=>track.stop());
  const overlay = document.getElementById('callOverlay');
  if(overlay) overlay.remove();
  isCalling = false;
}
</script>

</body>
</html>
