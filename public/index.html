<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>èŠå¤©å®¤</title>
<style>
  :root {
    --sunset-yellow: #FFD54F;
    --light-red: #FF8A80;
    --warm-orange: #FFB74D;
    --cool-teal: #4DB6AC;
    --light-purple: #BA68C8;
    --light-pink: #F48FB1;
  }
  body {
    margin: 0;
    font-family: sans-serif;
    background: linear-gradient(135deg, var(--sunset-yellow) 0%, var(--light-red) 20%, var(--warm-orange) 40%, var(--cool-teal) 60%, var(--light-purple) 80%, var(--light-pink) 100%);
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255,255,255,0.2);
    padding: 10px;
    color: #fff;
    font-weight: bold;
    backdrop-filter: blur(5px);
  }
  .top-center {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .top-center img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }
  .top-bar button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
  }
  #log {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }
  .msg {
    max-width: 70%;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 12px;
    color: #000;
    background: rgba(255,255,255,0.8);
    word-wrap: break-word;
  }
  .me { background: #DCF8C6; align-self: flex-end; }
  .other { background: rgba(255,255,255,0.6); align-self: flex-start; }
  .system { background: rgba(200,200,200,0.7); text-align: center; color: #000; }
  .input-area {
    display: flex;
    padding: 10px;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(5px);
    position: relative;
  }
  #msg { flex: 1; padding: 8px; border: none; border-radius: 20px; outline: none; }
  #sendBtn, #emojiBtn { margin-left: 5px; padding: 8px 12px; border: none; border-radius: 20px; cursor: pointer; background: rgba(255,255,255,0.9); }

  /* è¡¨æƒ…é¢æ¿ */
  #emojiPanel {
    position: absolute;
    bottom: 50px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    border-radius: 8px;
    padding: 5px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  #emojiPanel button {
    font-size: 20px;
    border: none;
    background: none;
    cursor: pointer;
  }
  /* çŠ¶æ€æ ·å¼ */
  .status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 14px;
    color: #fff;
  }
  .status-circle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: breathe 2s infinite ease-in-out;
  }

  @keyframes breathe {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.6; }
  }

  /* æ ¹æ®ä¸åŒçŠ¶æ€åŠ¨æ€ä¿®æ”¹é¢œè‰²å’ŒåŠ¨ç”»æ—¶é—´ */
  .online { background: green; animation-duration: 2s; }
  .offline { background: gray; animation-duration: 10s; }
  .busy { background: yellow; animation-duration: 15s; }
  
  #callOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  #callStatus {
    margin-bottom: 20px;
    color: #fff;
    font-size: 20px;
  }
  #callTimer {
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    margin: 10px 0;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
  }
</style>
</head>
<body>

<div class="top-bar">
  <button onclick="window.location.href='/'">ğŸ </button>
  <div class="top-center">
    <img id="partnerAvatar" src="/image/f64be2438709ee1f11ad8754e282b1df.jpeg" alt="å¯¹æ–¹å¤´åƒ">
    <span id="partnerName">æœªçŸ¥ç”¨æˆ·</span>
    <div id="partnerStatus" class="status">
      <div id="statusCircle" class="status-circle offline"></div>
      <span id="statusText">ç¦»çº¿</span>
    </div>
  </div>
  <button onclick="startCall()">ğŸ“</button>
</div>

<div id="log"></div>

<div class="input-area">
  <input id="msg" placeholder="è¾“å…¥æ¶ˆæ¯..." />
  <button id="emojiBtn" onclick="toggleEmojiPanel()">ğŸ˜Š</button>
  <button id="sendBtn" onclick="send()" disabled>å‘é€</button>
</div>

<!-- é€šè¯æµ®å±‚ -->
<div id="callUI" class="hidden"></div>

<script type="module">
import { secp256k1 } from 'https://esm.sh/@noble/curves/secp256k1';
import { schnorr } from 'https://esm.sh/@noble/curves/secp256k1'; 
// ç”Ÿæˆç§é’¥å¹¶è®¡ç®—å…¬é’¥
const priv = new Uint8Array(32);
crypto.getRandomValues(priv);
console.log(priv); 
  
const pubtype = secp256k1.getPublicKey(priv, false); 
const pub = pubtype.slice(1, 33);  
window.myPrivKey = priv;   
window.myPubKey  = toHex(pub); 
window.startCall = startCall;
  // === ç”Ÿæˆå‡­è¯ ===
  async function generateCredential() {
    const now = Math.floor(Date.now() / 1000); // ç§’çº§æ—¶é—´æˆ³
    const expireAt = now + 7 * 24 * 60 * 60; // +7å¤©
    const payload = {
      pubkey: window.myPubKey,
      issuedAt: now,
      expireAt: expireAt
    };
    const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
    const uint8Hash = new Uint8Array(hash);
    const id = toHex(uint8Hash);

    const sigUint8 = await schnorr.sign(uint8Hash, window.myPrivKey);
    const sig = toHex(sigUint8);
    const credential = {
      ...payload,
      id,
      sig
    };

    window.credential = credential; // æŒ‚åˆ°å…¨å±€
    console.log("å‡­è¯ç”Ÿæˆ:", credential);
  }
  
  generateCredential();

  function toHex(bytes) {
    console.log("ä¼ å…¥æœ‰æ•ˆå‚æ•°:",bytes)
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }
  
  const partnerAvatar = document.getElementById("partnerAvatar");//å¤´åƒ
  const partnerName = document.getElementById("partnerName");
  const logDiv = document.getElementById("log");
  const socket = new WebSocket("wss://relay.damus.io");
  window.myPubKey = toHex(pub);
  console.log("pubkey:", window.myPubKey);
  window.name = "";   
  window.onload = () => {
    let name = "";
    do {
      name = prompt("è¯·è¾“å…¥ä½ çš„æ˜µç§°:");
    } while(!name || name.trim() === "");
    window.name = name;  
  };
  
  let myRoom = null;
  let partnerInfo = { name: "æœªçŸ¥ç”¨æˆ·", avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg", online: false };
  let emojis = [];
  const mysMap = {}; // pubkey â†’ ç”¨æˆ·åæ˜ å°„
  // å…¨å±€å˜é‡ç”¨äºå­˜å‚¨è®¡æ—¶å™¨
  let callTimerInterval = null;
  let callStartTime = null;
  
  //çŠ¶æ€åˆ¤æ–­
  function setPartnerStatus(state){
    const circle = document.getElementById("statusCircle");
    const text = document.getElementById("statusText");
    circle.className = "status-circle " + state;
    if(state === "online") {
      text.textContent = "åœ¨çº¿";
      partnerInfo.online = true;
    } else if(state === "offline") {
      text.textContent = "ç¦»çº¿";
      partnerInfo.online = false;
    } else if(state === "busy") {
      text.textContent = "ç¹å¿™";
      partnerInfo.online = true; 
    }
    partnerInfo.state = state;
    console.log("partnerInfo:", partnerInfo); 
  }
  
  // -------------------- è¡¨æƒ…åŒ… --------------------
  function toggleEmojiPanel(){
    let panel = document.getElementById('emojiPanel');
    if(panel) { panel.remove(); return; }
    
    fetch('other/emojis.json')
      .then(res => res.json())
      .then(data => emojis = data);  

    panel = document.createElement('div');
    panel.id = 'emojiPanel';
    emojis.forEach(e=>{
      const btn = document.createElement('button');
      btn.innerText = e.symbol;
      btn.onclick = ()=> insertEmoji(e.symbol);
      panel.appendChild(btn);
    });
    document.querySelector('.input-area').appendChild(panel);
  }

  function insertEmoji(symbol){
    const msgInput = document.getElementById("msg");
    msgInput.value += symbol;
    msgInput.focus();
  }
  
window.send=async function send(eventobj=null) {
  if (eventobj) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(["EVENT", eventobj]));
      return;
    } else {
      log("ä¿¡ä»¤å‘é€å¤±è´¥ï¼ŒWebSocketæœªè¿æ¥", "system");
      return;
    }
  }

  if (!eventobj) {
    const msgInput = document.getElementById("msg");
    const msg = msgInput.value.trim();
    if (!msg) return;

    if (socket.readyState === WebSocket.OPEN) {
      const eventobj = {
        id: "",
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10021"]],
        content: msg
      };

      // è®¡ç®— id
      const payload = [0, eventobj.pubkey, eventobj.created_at, eventobj.kind, eventobj.tags, eventobj.content];
      const serialized = JSON.stringify(payload);
      const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized));
      const uint8Hash = new Uint8Array(hash);
      eventobj.id = toHex(uint8Hash);
      const sigUint8 = await schnorr.sign(uint8Hash, window.myPrivKey);
      eventobj.sig = toHex(sigUint8);
      console.log("è½¬æ¢åçš„sigæ‰“å°å‡º:", eventobj.sig);

      // å‘é€
      socket.send(JSON.stringify(["EVENT", eventobj]));
      
      if (!eventobj.tags.some(t => t[0] === "t")) {
        document.getElementById("msg").value = "";
        log(`${msg}`, "me");
      }
    } else {
      log("âš ï¸ è¿æ¥å°šæœªå»ºç«‹æˆ–æˆ¿é—´æœªåˆ†é…", "system");
    }
  }
}
  // ç¡®ä¿ DOM åŠ è½½åå†ç»‘å®šäº‹ä»¶
  window.addEventListener("DOMContentLoaded", () => {
    const sendBtn = document.getElementById("sendBtn");
    sendBtn.addEventListener("click", () => send());
  });
  
  function announceJoin(sername, pubkey, avatar) {
    // å…ˆæŠŠè‡ªå·±åŠ è¿›åœ¨çº¿åˆ—è¡¨
    participants.push({
      pubkey: window.myPubKey,
      username: window.name,
      avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
      lastSeen: Date.now()
    });
    console.log("ä½ å·²åŠ å…¥èŠå¤©å®¤ï¼Œå½“å‰äººæ•°ï¼š",  participants.length);

    // å¹¿æ’­ JOIN æ¶ˆæ¯ï¼Œè®©åˆ«äººçŸ¥é“ä½ ä¸Šçº¿äº†
    send({
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10021"], ["status", "JOIN"]],
      content: window.name + " åŠ å…¥äº†èŠå¤©å®¤"
    });
  }
  
  // å®šä¹‰ handleSignal å‡½æ•°
  async function handleSignal(data) {
    switch (data.type) {
      case "offer":
        if (!isCalling) {
          await initPeerConnection();
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          socket.send(JSON.stringify({
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            tags: [["t", "room10021"], ["call", "answer"]],
            content: JSON.stringify({
              type: "answer",
              answer: answer,
              name: window.name
            })
          }));
          alert(`${data.name} å‘èµ·äº†è¯­éŸ³é€šè¯`);
        }
        break;

      case "answer":
        if (peerConnection) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
        break;

      case "ice":
        if (peerConnection && data.candidate) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
        break;

      case "hangup":
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        isCalling = false;
        removeCallOverlay();
        break;
    }
  }
  
  // ç”¨æˆ·ç®¡ç†é€»è¾‘
  function handleEvent(event) {
    const tags = event.tags || [];
    const statusTag = tags.find(t => t[0] === "status");
    const pubkey = event.pubkey;
    const isMe = pubkey === window.myPubKey;

    // è·å–æˆ–åˆ›å»ºç”¨æˆ·ä¿¡æ¯
    let user = participants.find(p => p.pubkey === pubkey);
    if (!user) {
      user = {
        pubkey: pubkey,
        username: isMe ? window.name : pubkey.slice(0, 8),
        avatar: "https://robohash.org/" + pubkey,
        lastSeen: Date.now()
      };
      participants.push(user);
    } else {
      user.lastSeen = Date.now();
    }

    // å¤„ç†çŠ¶æ€æ ‡ç­¾
    if (statusTag) {
      if (statusTag[1] === "JOIN") {
        log(`${user.username} åŠ å…¥äº†èŠå¤©å®¤`, "system");
      } else if (statusTag[1] === "LEAVE") {
        participants = participants.filter(p => p.pubkey !== pubkey);
        log(`${user.username} ç¦»å¼€äº†èŠå¤©å®¤`, "system");
        return;
      }
    }
    
    // å¤„ç†æ™®é€šæ¶ˆæ¯
    if (event.content && !event.content.includes("åŠ å…¥äº†èŠå¤©å®¤") && !event.content.includes("ç¦»å¼€äº†èŠå¤©å®¤")) {
      log(`${user.username}: ${event.content}`, isMe ? "me" : "other");
    }
    
    // æ›´æ–°partnerInfoï¼ˆå¦‚æœæ˜¯å¯¹æ–¹ï¼‰
    if (!isMe) {
      partnerInfo.pubkey = pubkey;
      partnerInfo.username = user.username;
      partnerInfo.avatar = user.avatar;
      partnerInfo.online = true;
      
      partnerName.textContent = partnerInfo.username;
      partnerAvatar.src = partnerInfo.avatar;
      setPartnerStatus("online");
    }
  }

  let participants = [];
  socket.onopen = () => {
    log("âœ… å·²è¿æ¥Relayç½‘ç»œèŠå¤©å®¤", "system");
    announceJoin();  // å¹¿æ’­è‡ªå·±ä¸Šçº¿
    setPartnerStatus("online");//åŠ å…¥èŠå¤©å®¤åï¼Œé»˜è®¤åœ¨çº¿çŠ¶æ€
    console.log("å½“å‰çŠ¶æ€:", setPartnerStatus("online"));
    document.getElementById("sendBtn").disabled = false;
    
    socket.send(
      JSON.stringify(
        [
          "REQ", 
          "sub1",
          { 
            kinds:[1],
            "#t": ["room10021"] 
          }
        ]
      )
    );
    
    // å‘ä¸€æ¡ system join æ¶ˆæ¯
    const joinEvent = {
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10021"]],
      content: `${window.name} åŠ å…¥äº†èŠå¤©å®¤`
    };
    
    mysMap[window.myPubKey] = window.name; // ä¿å­˜æ˜ å°„
    participants.push({
      pubkey: window.myPubKey,
      name: window.name,
      avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
      lastSeen: Date.now()
    });
    
    send(joinEvent);
  };
  
  socket.onmessage = async (e) => {
    try {
      const data = JSON.parse(e.data);
      console.log("æ”¶åˆ°:", e.data);
      
      // 1. å¤„ç†æ•°ç»„æ ¼å¼çš„æ¶ˆæ¯ (Nostråè®®æ ‡å‡†æ ¼å¼)
      if (Array.isArray(data)) {
        if (data[0] === "OK") {
          console.log("Relayç¡®è®¤:", data);
          return;
        }
        
        if (data[0] === "EOSE") {
          console.log("EOSE æ”¶åˆ°:", data[1]);
          return;
        }
        
        if (data[0] === "EVENT") {
          const event = data[2];
          if (!event || !event.pubkey) return;
          
          // æ›´æ–°ç”¨æˆ·æ˜ å°„
          if (!mysMap[event.pubkey]) {
            mysMap[event.pubkey] = event.username || event.pubkey.slice(0, 8); 
          }
          
          console.log("å½“å‰åœ¨çº¿ç”¨æˆ·:", Object.values(mysMap));
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯é€šè¯ç›¸å…³äº‹ä»¶
          const callTag = event.tags?.find(t => t[0] === "call");
          if (callTag) {
            try {
              const signal = JSON.parse(event.content);
              // åªå¤„ç†æ¥è‡ªå¯¹æ–¹çš„æ¶ˆæ¯ï¼ˆæ’é™¤è‡ªå·±å‘é€çš„æ¶ˆæ¯ï¼‰
              if (event.pubkey === window.myPubKey) {
                console.log("å¿½ç•¥è‡ªå·±å‘é€çš„ä¿¡ä»¤æ¶ˆæ¯");
                return;
              }
              
              // å¤„ç†æ¥ç”µ
              if (callTag[1] === "offer" && !isCalling) {
                window.incomingOffer = new RTCSessionDescription({ type: "offer", sdp: signal.sdp });
                partnerInfo.username = signal.username || "æœªçŸ¥ç”¨æˆ·";
                partnerName.textContent = partnerInfo.username;    
                // æ˜¾ç¤ºæ¥ç”µç•Œé¢
                showCallOverlay(true); // æ˜¾ç¤ºè¢«å«ç•Œé¢
                alert(`${partnerInfo.username} å‘èµ·äº†è¯­éŸ³é€šè¯`);
                return;
              }
              
              // å¤„ç†å…¶ä»–ä¿¡ä»¤ï¼ˆanswerã€iceç­‰ï¼‰
              if (peerConnection) {
                console.log("å¤„ç†ä¿¡ä»¤:", callTag[1], "å½“å‰çŠ¶æ€:", peerConnection.signalingState);
                
                if (callTag[1] === "answer") {
                  console.log("è®¾ç½®è¿œç¨‹answer");
                  await peerConnection.setRemoteDescription(
                    new RTCSessionDescription({
                      type: "answer",
                      sdp: signal.sdp
                    })
                  );
                } else if (callTag[1] === "ice") {
                  if (peerConnection.remoteDescription) {
                    console.log("æ·»åŠ ICEå€™é€‰");
                    await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                  } else {
                    console.log("ç¼“å­˜ICEå€™é€‰ï¼Œç­‰å¾…è¿œç¨‹æè¿°");
                    // å¯ä»¥ç¼“å­˜ICEå€™é€‰ï¼Œç­‰åˆ°æœ‰è¿œç¨‹æè¿°åå†æ·»åŠ 
                  }
                } else if (callTag[1] === "hangup") {
                  console.log("æ”¶åˆ°æŒ‚æ–­ä¿¡ä»¤");
                  endCall(false);
                }else if (callTag[1] === "accept-call") {
                   console.log("æ”¶åˆ°æ¥å¬ä¿¡ä»¤");
                   const signal = JSON.parse(event.content);
                  // åªå¤„ç†å‘ç»™æˆ‘çš„ accept-call
                  if (signal.to === window.myPubKey) {
                      // åœæ­¢å“é“ƒ
                      const audio = document.querySelector('#callOverlay audio');
                      if (audio) {
                          audio.pause();
                          audio.currentTime = 0;
                      }
                      // æ›´æ–° UI
                     const cs = document.getElementById('callStatus');
                    if (cs) cs.innerText = "é€šè¯ä¸­...";
                    // å¯åŠ¨è®¡æ—¶å™¨ï¼ˆä½¿ç”¨å¯¹æ–¹å›ä¼ çš„ startTimeï¼Œä¿è¯åŒæ­¥ï¼‰
                    if (signal.startTime) {
                      startCallTimer(signal.startTime);
                    } else {
                      startCallTimer(Date.now()); // å…œåº•
                    }
                 }
              }
                      // === ç§»é™¤æ¥å¬æŒ‰é’®ï¼Œåªä¿ç•™æŒ‚æ–­ ===
                     const btnContainer = document.querySelector('#callOverlay div');
                     if (btnContainer) {
                         btnContainer.innerHTML = '';
                          const hangupBtn = document.createElement('button');
                          hangupBtn.id = 'hangupBtn';
                          hangupBtn.innerText = 'æŒ‚æ–­';
                          hangupBtn.onclick = () => endCall(true);
                          btnContainer.appendChild(hangupBtn);
                      }
                    // æ›´æ–° UI
                     const callStatus = document.getElementById('callStatus');
                     if (callStatus) {
                         callStatus.innerText = "é€šè¯ä¸­...";
                     }
                      acceptCall(from);
                     // å¯åŠ¨è®¡æ—¶å™¨ï¼ˆç”¨æ¥æ”¶æ–¹çš„ startTime ä¿æŒåŒæ­¥ï¼‰
                     startCallTimer(signal.startTime);
                   }
                } catch (err) {
              console.error("è§£æé€šè¯ä¿¡ä»¤å¤±è´¥", err);
            }
            return;
          }
          
          // å¤„ç†æ™®é€šäº‹ä»¶
          handleEvent(event);
          return;
        }
      }
      
      // 2. å¤„ç†éæ ‡å‡†æ ¼å¼çš„æ¶ˆæ¯ï¼ˆç³»ç»Ÿæ¶ˆæ¯å’Œæ—§ç‰ˆä¿¡ä»¤ï¼‰
      if (data.system) {
        log(data.msg, "system");
        return;
      }
      
      // å¤„ç†æ—§ç‰ˆä¿¡ä»¤æ ¼å¼ï¼ˆåº”è¯¥é€æ­¥è¿ç§»åˆ°ä½¿ç”¨Nosträº‹ä»¶çš„æ ‡å‡†æ ¼å¼ï¼‰
      if (data.type === 'offer' && !isCalling) {
        window.incomingOffer = data.offer;
        partnerInfo.username = data.username;
        partnerName.textContent = partnerInfo.username;
        partnerAvatar.src = data.avatar || partnerAvatar.src;
        startCall(true);
        return;
      }

      if (data.type === 'answer') {
        if (peerConnection) {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(
              data.answer
            )
          );
        }
        return;
      } else if (data.type === 'ice' && data.candidate) {
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      }
        if (data.type) {
          await handleSignal(data);
          return;
        }

     }
      catch (err) {
      console.error("è§£æå¤±è´¥", e.data, err);
      log("è§£æå¤±è´¥: " + e.data, "system");
    }
  }
  socket.onerror = () => log("âŒ è¿æ¥å‡ºé”™", "system");

  function log(message, type="other"){
    const logDiv = document.getElementById("log");
    if(!logDiv) return; 
    const msgDiv = document.createElement("div");
    msgDiv.className = `msg ${type}`;
    msgDiv.textContent = message;
    logDiv.appendChild(msgDiv);
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // -------------------- WebRTCè¯­éŸ³é€šè¯ --------------------
  let localStream, peerConnection, isCalling = false;
  const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  
  async function initPeerConnection() {
    try {
      // å¦‚æœå·²å­˜åœ¨PeerConnectionï¼Œå…ˆå…³é—­å®ƒ
      if (peerConnection) {
        peerConnection.close();
      }
      
      peerConnection = new RTCPeerConnection(config);
      
      // æ·»åŠ çŠ¶æ€ç›‘å¬
      peerConnection.onconnectionstatechange = () => {
        console.log("è¿æ¥çŠ¶æ€å˜åŒ–:", peerConnection.connectionState);
      };
      
      peerConnection.onsignalingstatechange = () => {
        console.log("ä¿¡ä»¤çŠ¶æ€å˜åŒ–:", peerConnection.signalingState);
      };
      
      peerConnection.oniceconnectionstatechange = () => {
        console.log("ICEè¿æ¥çŠ¶æ€å˜åŒ–:", peerConnection.iceConnectionState);
      };
      
      peerConnection.onicegatheringstatechange = () => {
        console.log("ICEæ”¶é›†çŠ¶æ€å˜åŒ–:", peerConnection.iceGatheringState);
      };

      // è·å–æœ¬åœ°éŸ³é¢‘æµ
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      // æ’­æ”¾è¿œç«¯éŸ³é¢‘
      peerConnection.ontrack = (event) => {
        console.log("æ”¶åˆ°è¿œç«¯éŸ³è½¨");
        let remoteAudio = document.getElementById("remoteAudio");
        if (!remoteAudio) {
          remoteAudio = document.createElement("audio");
          remoteAudio.id = "remoteAudio";
          remoteAudio.autoplay = true;
          document.body.appendChild(remoteAudio);
        }
        remoteAudio.srcObject = event.streams[0];
        remoteAudio.play();
      };

      // å¤„ç† ICE å€™é€‰
      peerConnection.onicecandidate = async (event) => {
        if (event.candidate) {
          console.log("ç”ŸæˆICEå€™é€‰");
          const iceEvent = {
            pubkey: window.myPubKey,
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            tags: [["t", "room10021"], ["call", "ice"]],
            content: JSON.stringify({ 
              type: "ice", 
              candidate: event.candidate 
            })
          };
          
          // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
          const payload = [0, iceEvent.pubkey, iceEvent.created_at, iceEvent.kind, iceEvent.tags, iceEvent.content];
          const serialized = JSON.stringify(payload);
          const hash = new Uint8Array(
            await crypto.subtle.digest(
              "SHA-256", 
              new TextEncoder().encode(serialized)
            )
          );
          iceEvent.id = toHex(hash);
          const sig = await schnorr.sign(hash, window.myPrivKey); 
          iceEvent.sig = toHex(sig);
          
          // å‘é€ICEå€™é€‰äº‹ä»¶
          socket.send(JSON.stringify(["EVENT", iceEvent]));
        } else {
          console.log("ICEå€™é€‰æ”¶é›†å®Œæˆ");
        }
      };
      
    } catch (err) {
      console.error("åˆå§‹åŒ–PeerConnectionå¤±è´¥", err);
      alert("åˆå§‹åŒ–è¯­éŸ³é€šè¯å¤±è´¥: " + err.message);
      endCall(true);
    }
  }
  
  // æ·»åŠ ä¸€ä¸ªå‡½æ•°æ¥æ£€æŸ¥å¹¶æ¢å¤PeerConnectionçŠ¶æ€
  function checkAndResetPeerConnection() {
    if (peerConnection) {
      const state = peerConnection.signalingState;
      console.log("å½“å‰PeerConnectionçŠ¶æ€:", state);
      
      // å¦‚æœçŠ¶æ€ä¸æ˜¯stableï¼Œå¯èƒ½éœ€è¦é‡ç½®
      if (state !== "stable") {
        console.log("é‡ç½®PeerConnection");
        peerConnection.close();
        peerConnection = null;
        return false;
      }
    }
    return true;
  }
  
  function getOnlineUsers() {
    return participants.filter(
      p => p.pubkey !== window.myPubKey && (Date.now() - p.lastSeen) < 10*60 * 1000
    );
  }
  
  async function startCall(isIncoming = false) {
    console.log("å‘èµ·é€šè¯ï¼ŒisIncoming:", isIncoming);
    // æ£€æŸ¥å¹¶é‡ç½®PeerConnectionçŠ¶æ€
    if (!checkAndResetPeerConnection()) {
      console.log("PeerConnectionçŠ¶æ€å¼‚å¸¸ï¼Œå·²é‡ç½®");
    }

    // æ£€æŸ¥åœ¨çº¿ç”¨æˆ·
    const onlineUsers = participants.filter(
      p => p.pubkey !== window.myPubKey && (Date.now() - p.lastSeen) < 100 * 60 * 1000
    );
    console.log("å½“å‰åœ¨çº¿ç”¨æˆ·:", onlineUsers);
    
    if (onlineUsers.length === 0) {
      alert("å½“å‰èŠå¤©å®¤æ²¡æœ‰å…¶ä»–åœ¨çº¿ç”¨æˆ·ï¼Œæ— æ³•å‘èµ·é€šè¯");
      return;
    }

    const now = Math.floor(Date.now() / 1000);
    if (!window.credential || now > window.credential.expireAt) {
      alert("å‡­è¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–");
      return;
    }

    // ç¡®ä¿ peerConnection å­˜åœ¨
    if (!peerConnection || peerConnection.signalingState === "closed") {
      await initPeerConnection();
    }

    // å¦‚æœæ˜¯ä¸»å«æ–¹ï¼ˆå‘èµ·é€šè¯ï¼‰
    if (!isIncoming) {
      const startTime = Date.now();  // ç»Ÿä¸€é€šè¯å¼€å§‹æ—¶é—´
      startCallTimer(startTime);      // è‡ªå·±å¯åŠ¨è®¡æ—¶å™¨
      // åˆ›å»ºå¹¶å‘é€offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      
      // åˆ›å»ºé€šè¯äº‹ä»¶
      const callEvent = {
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10021"], ["call", "offer"]],
        content: JSON.stringify({
          type: "offer",
          sdp: offer.sdp,
          username: window.name,
          startTime:startTime
        })
      };
      
      // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
      const payload = [0, callEvent.pubkey, callEvent.created_at, callEvent.kind, callEvent.tags, callEvent.content];
      const serialized = JSON.stringify(payload);
      const hash = new Uint8Array(
         await crypto.subtle.digest(
            "SHA-256", 
             new TextEncoder().encode(serialized)
         )
      );
      callEvent.id = toHex(hash);
      const sig = await schnorr.sign(hash, window.myPrivKey);
      callEvent.sig = toHex(sig);
      // å‘é€é€šè¯äº‹ä»¶
      socket.send(JSON.stringify(["EVENT", callEvent]));
      log("ğŸ“ å·²å‘é€å‘¼å«è¯·æ±‚", "system");
      // æ˜¾ç¤ºé€šè¯ç•Œé¢
      showCallOverlay(isIncoming);
      // å¯åŠ¨è®¡æ—¶å™¨ï¼ˆä¸»å«æ–¹è®¡æ—¶å¯ä»¥ä»å½“å‰æ—¶é—´å¼€å§‹ï¼‰
      startCallTimer(Date.now());
      isCalling = true;
    }
  }

// æ˜¾ç¤ºé€šè¯ç•Œé¢çš„å‡½æ•°
function showCallOverlay(isIncoming) {
  // ç§»é™¤å·²å­˜åœ¨çš„é€šè¯ç•Œé¢ï¼ˆå¦‚æœæœ‰ï¼‰
  const existingOverlay = document.getElementById('callOverlay');
  if (existingOverlay) {
    existingOverlay.remove();
  }
  
  const callOverlay = document.createElement('div');
  callOverlay.id = 'callOverlay';
  Object.assign(callOverlay.style, {
    position: 'fixed', 
    top: 0, 
    left: 0, 
    width: '100%', 
    height: '100%',
    background: 'rgba(0,0,0,0.6)', 
    backdropFilter: 'blur(10px)',
    display: 'flex', 
    flexDirection: 'column', 
    justifyContent: 'center', 
    alignItems: 'center',
    zIndex: 9999
  });

  // çŠ¶æ€æ–‡å­—
  const status = document.createElement('div');
  status.id = 'callStatus';
  status.innerText = isIncoming 
    ? `${partnerInfo.username} æ¥ç”µ` 
    : 'æ­£åœ¨ç­‰å¾…å¯¹æ–¹æ¥å¬...';
  Object.assign(status.style, {
    marginBottom: '20px', 
    color: '#fff', 
    fontSize: '20px'
  });
  callOverlay.appendChild(status);
  
  // é€šè¯è®¡æ—¶å™¨
  const timer = document.createElement('div');
  timer.id = 'callTimer';
  timer.innerText = '00:00:00';
  Object.assign(timer.style, {
    marginBottom: '20px', 
    color: '#fff', 
    fontSize: '24px',
    fontWeight: 'bold'
  });
  callOverlay.appendChild(timer);
  
  // åªåœ¨ä¸»å«æ–¹æ’­æ”¾é“ƒå£°
  if (!isIncoming) {
    const audio = document.createElement('audio');
    audio.src = 'sound/DaDaDum - The Soundlings.mp3';
    audio.loop = true;
    audio.autoplay = true;
    callOverlay.appendChild(audio);
  }

  // åˆ›å»ºæŒ‰é’®å®¹å™¨
  const btnContainer = document.createElement('div');
  btnContainer.style.display = 'flex';
  btnContainer.style.gap = '60px';
  btnContainer.style.alignItems = 'center';

  // === æ‹’ç»æŒ‰é’® ===
  const rejectBtn = document.createElement('button');
  rejectBtn.innerText = 'æŒ‚æ–­';
  rejectBtn.className = 'call-btn';
  Object.assign(rejectBtn.style, {
    width: '90px',
    height: '90px',
    borderRadius: '50%',
    border: 'none',
    color: '#fff',
    fontSize: '18px',
    cursor: 'pointer',
    background: 'red',
    position: 'relative',
    overflow: 'hidden'
  });
  if (!isIncoming) {
    // ä¸»å«æ–¹çš„æŒ‚æ–­æŒ‰é’®ï¼šå‘¼å¸+è·³åŠ¨
    rejectBtn.style.boxShadow = '0 0 20px rgba(255,255,255,0.8)';
    rejectBtn.style.animation = 'breathe 2s infinite, jump 1.5s infinite';
  }
  rejectBtn.onclick = () => endCall(true);

  // === æ¥å¬æŒ‰é’®ï¼ˆä»…æ¥ç”µæ—¶æ˜¾ç¤ºï¼‰ ===
  if (isIncoming) {
    const acceptWrapper = document.createElement('div');
    acceptWrapper.style.position = 'relative';

    const acceptBtn = document.createElement('button');
    acceptBtn.innerText = 'æ¥å¬';
    acceptBtn.className = 'call-btn';
    Object.assign(acceptBtn.style, {
      width: '90px',
      height: '90px',
      borderRadius: '50%',
      border: 'none',
      color: '#fff',
      fontSize: '18px',
      cursor: 'pointer',
      background: 'green',
      position: 'relative'
    });
    acceptWrapper.appendChild(acceptBtn);

    // å‘ä¸Šç®­å¤´
    const arrowUp = document.createElement('div');
    arrowUp.innerHTML = `
      <svg viewBox="0 0 24 24" style="width:30px;height:30px;fill:url(#grad);">
        <path d="M12 2 L6 12 H10 V22 H14 V12 H18 Z"/>
      </svg>
    `;
    Object.assign(arrowUp.style, {
      position: 'absolute',
      top: '-40px',
      left: '30px',
      animation: 'arrowFlowUp 1.5s linear infinite'
    });
    acceptWrapper.appendChild(arrowUp);

    // ç‚¹å‡»å’Œæ»‘åŠ¨
    acceptBtn.onclick = () => acceptCall();
    let startY = null;
    acceptBtn.addEventListener("touchstart", e => {
      startY = e.touches[0].clientY;
    });
    acceptBtn.addEventListener("touchend", e => {
      const endY = e.changedTouches[0].clientY;
      if (startY - endY > 50) {
        acceptCall();
      }
    });

    btnContainer.appendChild(acceptWrapper);
  }

  // å¦‚æœæ˜¯æ¥æ”¶æ–¹ï¼ŒåŠ ä¸Šæ‹’ç»æŒ‰é’®çš„å³ç®­å¤´
  if (isIncoming) {
    const rejectWrapper = document.createElement('div');
    rejectWrapper.style.position = 'relative';
    rejectWrapper.appendChild(rejectBtn);

    const arrowRight = document.createElement('div');
    arrowRight.innerHTML = `
      <svg viewBox="0 0 24 24" style="width:30px;height:30px;fill:url(#grad);">
        <path d="M22 12 L12 6 V10 H2 V14 H12 V18 Z"/>
      </svg>
    `;
    Object.assign(arrowRight.style, {
      position: 'absolute',
      right: '-40px',
      top: '30px',
      animation: 'arrowFlowRight 1.5s linear infinite'
    });
    rejectWrapper.appendChild(arrowRight);

    // ç‚¹å‡»å’Œæ»‘åŠ¨
    let startX = null;
    rejectBtn.addEventListener("touchstart", e => {
      startX = e.touches[0].clientX;
    });
    rejectBtn.addEventListener("touchend", e => {
      const endX = e.changedTouches[0].clientX;
      if (endX - startX > 50) {
        endCall(true);
      }
    });

    btnContainer.appendChild(rejectWrapper);
  } else {
    btnContainer.appendChild(rejectBtn);
  }

  callOverlay.appendChild(btnContainer);

  // æ³¨å…¥å…¨å±€ SVG æ¸å˜ & åŠ¨ç”» keyframesï¼ˆåªæ³¨å…¥ä¸€æ¬¡ï¼‰
  if (!document.getElementById("callOverlayStyles")) {
    const style = document.createElement("style");
    style.id = "callOverlayStyles";
    style.innerHTML = `
      @keyframes breathe {
        0%, 100% { box-shadow: 0 0 20px rgba(255,255,255,0.6); }
        50% { box-shadow: 0 0 40px rgba(255,255,255,1); }
      }
      @keyframes jump {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-6px); }
      }
      @keyframes arrowFlowUp {
        from { transform: translateY(20px); opacity: 0.2; }
        to { transform: translateY(-20px); opacity: 1; }
      }
      @keyframes arrowFlowRight {
        from { transform: translateX(-20px); opacity: 0.2; }
        to { transform: translateX(20px); opacity: 1; }
      }
    `;
    document.head.appendChild(style);

    const svgDef = document.createElement("div");
    svgDef.innerHTML = `
      <svg width="0" height="0">
        <defs>
          <linearGradient id="grad" gradientTransform="rotate(90)">
            <stop offset="0%" stop-color="white" stop-opacity="0"/>
            <stop offset="50%" stop-color="white" stop-opacity="0.8"/>
            <stop offset="100%" stop-color="white" stop-opacity="0"/>
          </linearGradient>
        </defs>
      </svg>
    `;
    document.body.appendChild(svgDef);
  }
  document.body.appendChild(callOverlay);
}
// å¯åŠ¨é€šè¯è®¡æ—¶å™¨
function startCallTimer(startTimestamp) {
   if (callTimerInterval) {
      clearInterval(callTimerInterval);
   }
    callStartTime = new Date(startTimestamp);
    updateCallTimer(); // ç«‹å³åˆ·æ–°ä¸€æ¬¡
    callTimerInterval = setInterval(updateCallTimer, 1000);
}
// æ›´æ–°é€šè¯è®¡æ—¶å™¨æ˜¾ç¤º
function updateCallTimer() {
  if (!callStartTime) return;
    const elapsed = Math.floor((new Date() - callStartTime) / 1000); 
    const hours = String(Math.floor(elapsed / 3600)).padStart(2, '0');
    const minutes = String(Math.floor((elapsed % 3600) / 60)).padStart(2, '0');
    const seconds = String(elapsed % 60).padStart(2, '0');
    const timerElement = document.getElementById('callTimer');
    if (timerElement) timerElement.textContent = `${hours}:${minutes}:${seconds}`;
}
// åœæ­¢é€šè¯è®¡æ—¶å™¨
function stopCallTimer() {
  if (callTimerInterval) {
    clearInterval(callTimerInterval);
    callTimerInterval = null;
  }

  const timerElement = document.getElementById('callTimer');
  if (timerElement) {
    timerElement.innerText = '00:00:00';
  }
  callStartTime = null;
}
  
async function acceptCall(from,event) {
  try {
    if (!peerConnection) {
      await initPeerConnection();
    }

    if (!window.incomingOffer) {
      console.error("æ²¡æœ‰æ”¶åˆ° offerï¼Œæ— æ³•æ¥å¬");
      return;
    }

    // æ›´æ–°ç•Œé¢çŠ¶æ€
    const callStatus = document.getElementById('callStatus');
    if (callStatus) {
      callStatus.innerText = 'å·²æ¥å¬ï¼Œæ­£åœ¨å»ºç«‹é€šè¯...';
    }
    // åœæ­¢é“ƒå£°
    const audio = document.querySelector('#callOverlay audio');
    if (audio) {
      audio.pause();
      audio.currentTime = 0;
    }
    //éšè—æŒ‰é’®
     const acceptBtn = document.querySelector('#callOverlay button:nth-child(1)');
     if (acceptBtn) acceptBtn.remove();
     // ç§»é™¤æŒ‚æ–­æŒ‰é’®ä»¥å¤–çš„å¤šä½™æŒ‰é’®ï¼Œåªä¿ç•™æŒ‚æ–­
      const btnContainer = document.querySelector('#callOverlay div');
      if (btnContainer) {
         const hangupBtn = btnContainer.querySelector('button');
         btnContainer.innerHTML = '';
      }
    // è®¾ç½®è¿œç¨‹æè¿°
    await peerConnection.setRemoteDescription(new RTCSessionDescription(window.incomingOffer));
    // åˆ›å»ºå¹¶è®¾ç½®æœ¬åœ°æè¿°ï¼ˆAnswerï¼‰
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    // ========= å‘é€ Answer ç»™ä¸»å« =========
    const answerEvent = {
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10021"], ["call", "answer"]],
      content: JSON.stringify({
        type: 'answer',
        sdp: answer.sdp,
        username: window.name
      })
    };

    // è®¡ç®—äº‹ä»¶ ID å’Œç­¾å
    const payload = [0, answerEvent.pubkey, answerEvent.created_at, answerEvent.kind, answerEvent.tags, answerEvent.content];
    const serialized = JSON.stringify(payload);
    const hash = new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized)));
    answerEvent.id = toHex(hash);
    const sig = await schnorr.sign(new TextEncoder().encode(hash), window.myPrivKey);
    answerEvent.sig = toHex(sig);

    // å‘é€åº”ç­”äº‹ä»¶
    socket.send(JSON.stringify(["EVENT", answerEvent]));

    // ========= å‘é€ accept-call å¹¿æ’­ =========
    const startTime = Date.now();
    const acceptCallEvent = {
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10021"], ["call", "accept-call"]],
      content: JSON.stringify({
        type: "accept-call",
        to: from,       // å‘Šè¯‰ä¸»å«æ–¹æ˜¯å¯¹ä»–æ¥å¬
        startTime: window.incomingOffer.startTime      // ä¿è¯åŒæ–¹è®¡æ—¶åŒæ­¥
      })
    };
    socket.send(JSON.stringify(["EVENT", acceptCallEvent]));

    // ========= UI å’Œè®¡æ—¶ =========
    enterCall(); // å…ˆè¿›å…¥ UI
    const cs = document.getElementById('callStatus');
    if (cs) cs.innerText = "é€šè¯ä¸­...";
    const offerData = JSON.parse(event.content); // è§£æä¿¡ä»¤å†…å®¹
    // ä½¿ç”¨å‘èµ·è€…ä¼ æ¥çš„ startTimeï¼Œå¦‚æœæ²¡æœ‰å°±ç”¨å½“å‰æ—¶é—´ï¼ˆå…œåº•ï¼‰
    const callStartTimeFromCaller = offerData.startTime ? new Date(offerData.startTime) : new Date();
    // å¯åŠ¨è®¡æ—¶å™¨ï¼Œä½†ä½¿ç”¨å‘èµ·è€…æ—¶é—´
    startCallTimer(window.incomingOffer.startTime || Date.now());
  } catch (err) {
    console.error("æ¥å¬å¤±è´¥:", err);
  }
}

  async function endCall(isCaller = false) {
    console.log("ç»“æŸé€šè¯ï¼ŒisCaller:", isCaller);
    // åœæ­¢é€šè¯è®¡æ—¶å™¨
    stopCallTimer();
    
    // å‘é€æŒ‚æ–­ä¿¡ä»¤
    if (isCaller && socket && socket.readyState === WebSocket.OPEN) {
      const hangupEvent = {
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10021"], ["call", "hangup"]],
        content: JSON.stringify({
          type: "hangup"
        })
      };
      
      // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
      const payload = [0, hangupEvent.pubkey, hangupEvent.created_at, hangupEvent.kind, hangupEvent.tags, hangupEvent.content];
      const serialized = JSON.stringify(payload);
      const hash = new Uint8Array(
        await crypto.subtle.digest(
          "SHA-256",
          new TextEncoder().encode(serialized)
        )
      );
      hangupEvent.id = toHex(hash);
      const sig = await schnorr.sign(hash, window.myPrivKey);
      hangupEvent.sig = toHex(sig);
      socket.send(JSON.stringify(["EVENT", hangupEvent]));
    }
    
    // å…³é—­PeerConnection
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    
    // åœæ­¢æœ¬åœ°æµ
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    
    // ç§»é™¤é€šè¯ç•Œé¢
    const overlay = document.getElementById('callOverlay');
    if (overlay) {
      overlay.remove();
    }
    
    // ç§»é™¤è¿œç«¯éŸ³é¢‘å…ƒç´ 
    const remoteAudio = document.getElementById("remoteAudio");
    if (remoteAudio) {
      remoteAudio.remove();
    }
    
    isCalling = false;
    window.incomingOffer = null;
    
    log("é€šè¯å·²ç»“æŸ", "system");
  }
</script>
</body>
</html>
