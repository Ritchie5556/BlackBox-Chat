<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>聊天室</title>
<style>
  :root {
    --sunset-yellow: #FFD54F;
    --light-red: #FF8A80;
    --warm-orange: #FFB74D;
    --cool-teal: #4DB6AC;
    --light-purple: #BA68C8;
    --light-pink: #F48FB1;
  }
  body {
    margin: 0;
    font-family: sans-serif;
    background: linear-gradient(135deg, var(--sunset-yellow) 0%, var(--light-red) 20%, var(--warm-orange) 40%, var(--cool-teal) 60%, var(--light-purple) 80%, var(--light-pink) 100%);
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255,255,255,0.2);
    padding: 10px;
    color: #fff;
    font-weight: bold;
    backdrop-filter: blur(5px);
  }
  .top-center {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .top-center img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }
  .top-bar button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
  }
  #log {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }
  .msg {
    max-width: 70%;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 12px;
    color: #000;
    background: rgba(255,255,255,0.8);
    word-wrap: break-word;
  }
  .me { background: #DCF8C6; align-self: flex-end; }
  .other { background: rgba(255,255,255,0.6); align-self: flex-start; }
  .system { background: rgba(200,200,200,0.7); text-align: center; color: #000; }
  .input-area {
    display: flex;
    padding: 10px;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(5px);
    position: relative;
  }
  #msg { flex: 1; padding: 8px; border: none; border-radius: 20px; outline: none; }
  #sendBtn, #emojiBtn { margin-left: 5px; padding: 8px 12px; border: none; border-radius: 20px; cursor: pointer; background: rgba(255,255,255,0.9); }

  /* 表情面板 */
  #emojiPanel {
    position: absolute;
    bottom: 50px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    border-radius: 8px;
    padding: 5px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  #emojiPanel button {
    font-size: 20px;
    border: none;
    background: none;
    cursor: pointer;
  }
</style>
</head>
<body>

<div class="top-bar">
  <button onclick="window.location.href='/'">🏠</button>
  <div class="top-center">
    <img id="partnerAvatar" src="/image/f64be2438709ee1f11ad8754e282b1df.jpeg" alt="对方头像">
    <span id="partnerName">未知用户</span>
  </div>
  <button onclick="startCall()">📞</button>
</div>

<div id="log"></div>

<div class="input-area">
  <input id="msg" placeholder="输入消息..." />
  <button id="emojiBtn" onclick="toggleEmojiPanel()">😊</button>
  <button id="sendBtn" onclick="send()" disabled>发送</button>
</div>
<script type="module">
<script type="module">
import { secp256k1 } from "https://esm.sh/@noble/curves@1.8.1/secp256k1?target=es2020";

// 生成 Schnorr 密钥对
const privKey = secp256k1.utils.randomPrivateKey();
const pubKeyBytes = await secp256k1.schnorr.getPublicKey(privKey);

// 转成 hex 字符串（浏览器没有 Buffer）
const pubKeyHex = Array.from(pubKeyBytes).map(b => b.toString(16).padStart(2,'0')).join('');

console.log("私钥:", privKey);
console.log("公钥:", pubKeyHex);

// 如果需要全局使用
window.myPrivKey = privKey;
window.myPubKey = pubKeyHex;
window.nobleSchnorr = secp256k1.schnorr;

let username = prompt("请输入你的昵称");
while (!username || username.trim() === "") {
    username = prompt("昵称不能为空，请输入你的昵称");
}

const partnerAvatar = document.getElementById("partnerAvatar");
const partnerName = document.getElementById("partnerName");
const logDiv = document.getElementById("log");

const socket = new WebSocket("wss://blackbox-chat.onrender.com");
let myRoom = null;
let partnerInfo = {
    username: "未知用户",
    avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
    online: false
};

let emojis = [];

// -------------------- 表情包 --------------------
fetch('other/emojis.json')
    .then(res => res.json())
    .then(data => emojis = data);

function toggleEmojiPanel() {
    let panel = document.getElementById('emojiPanel');
    if (panel) {
        panel.remove();
        return;
    }
    panel = document.createElement('div');
    panel.id = 'emojiPanel';
    emojis.forEach(e => {
        const btn = document.createElement('button');
        btn.innerText = e.symbol;
        btn.onclick = () => insertEmoji(e.symbol);
        panel.appendChild(btn);
    });
    document.querySelector('.input-area').appendChild(panel);
}

function insertEmoji(symbol) {
    const msgInput = document.getElementById("msg");
    msgInput.value += symbol;
    msgInput.focus();
}

// -------------------- 聊天功能 --------------------
socket.onopen = () => {
    log("✅ 已连接聊天室", "system");
    document.getElementById("sendBtn").disabled = false;
    socket.send(JSON.stringify({
        system: true,
        join: true,
        username,
        avatar: "",
        requestRoom: true
    }));
};

socket.onmessage = async (e) => {
    try {
        const data = JSON.parse(e.data);

        if (data.system) {
            log(data.msg, "system");

            if (data.room) myRoom = data.room;

            if (data.join && data.username !== username) {
                partnerInfo.username = data.username;
                partnerInfo.avatar = data.avatar || partnerInfo.avatar;
                partnerInfo.online = true;
                partnerName.textContent = partnerInfo.username;
                partnerAvatar.src = partnerInfo.avatar;
                log(`${partnerInfo.username} 已加入房间`, "system");
            }

            if (data.join && data.username === username) {
                log("等待其他人加入...", "system");
            }

        } else if (data.username && data.msg && data.room === myRoom) {
            const type = data.username === username ? "me" : "other";
            const name = data.username || "未知用户";
            log(`${name}: ${data.msg}`, type);

            if (data.username !== username) {
                partnerInfo.username = data.username;
                partnerInfo.avatar = data.avatar || partnerAvatar.src;
                partnerInfo.online = true;
                partnerName.textContent = partnerInfo.username;
                partnerAvatar.src = partnerInfo.avatar;
            }

        } else if (data.type === 'offer' && !isCalling) {
            window.incomingOffer = data.offer;
            partnerInfo.username = data.username;
            partnerName.textContent = partnerInfo.username;
            partnerAvatar.src = data.avatar || partnerAvatar.src;
            startCall(true); // 被叫

        } else if (data.type === 'answer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));

        } else if (data.type === 'ice' && data.candidate) {
            if (peerConnection) await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }

    } catch {
        log(e.data, "other");
    }
};

socket.onerror = () => log("❌ 连接出错", "system");

async function send() {
    const msgInput = document.getElementById("msg");
    const msg = msgInput.value.trim();
    if (!msg) return;

    if (socket.readyState === WebSocket.OPEN && myRoom && partnerInfo.online) {
        const data = { username, msg, avatar: "", room: myRoom };
        socket.send(JSON.stringify(data));
        msgInput.value = "";
    } else if (!partnerInfo.online) {
        log("⚠️ 当前没有在线用户，等待其他人加入...", "system");
    } else {
        log("⚠️ 连接尚未建立或房间未分配", "system");
    }

    // 构造 Nostr Event
    const event = {
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [],
        content: msg
    };

    // 计算 id
    const payload = [0, event.pubkey, event.created_at, event.kind, event.tags, event.content];
    const hash = await window.crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
    event.id = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");

    // 用私钥签名
    const sig = await nobleSchnorr.sign(event.id, window.myPrivKey);
    event.sig = sig;

    // 发送给 Relay
    socket.send(JSON.stringify(["EVENT", event]));
    msgInput.value = "";
}

function log(message, type = "other") {
    const msgDiv = document.createElement("div");
    msgDiv.className = `msg ${type}`;
    msgDiv.textContent = message;
    logDiv.appendChild(msgDiv);
    logDiv.scrollTop = logDiv.scrollHeight;
}

// -------------------- WebRTC语音通话 --------------------
let localStream, peerConnection, isCalling = false;
const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

function startCall(isIncoming = false) {
    if (isCalling) return;
    if (!partnerInfo.online) {
        alert("对方不在线，无法通话");
        return;
    }

    isCalling = true;

    const callOverlay = document.createElement('div');
    callOverlay.id = 'callOverlay';
    Object.assign(callOverlay.style, {
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        background: 'rgba(255,255,255,0.2)',
        backdropFilter: 'blur(10px)',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 9999
    });

    const status = document.createElement('div');
    status.id = 'callStatus';
    status.innerText = isIncoming ? `${partnerInfo.username} 来电` : '正在等待对方接听...';
    Object.assign(status.style, { marginBottom: '20px', color: '#fff', fontSize: '20px' });
    callOverlay.appendChild(status);

    const audio = document.createElement('audio');
    audio.src = 'sound/DaDaDum - The Soundlings.mp3';
    audio.loop = true;
    audio.autoplay = true;
    callOverlay.appendChild(audio);

    const hangupBtn = document.createElement('button');
    hangupBtn.innerText = '📞挂断';
    Object.assign(hangupBtn.style, { background: 'red', color: '#fff', marginRight: '20px', padding: '10px 20px' });
    hangupBtn.onclick = () => endCall(true);

    const acceptBtn = document.createElement('button');
    acceptBtn.innerText = '📞接听';
    Object.assign(acceptBtn.style, { background: 'green', color: '#fff', padding: '10px 20px' });
    acceptBtn.onclick = acceptCall;

    const btnContainer = document.createElement('div');
    btnContainer.style.display = 'flex';
    btnContainer.style.gap = '20px';
    if (isIncoming) btnContainer.appendChild(acceptBtn);
    btnContainer.appendChild(hangupBtn);
    callOverlay.appendChild(btnContainer);

    document.body.appendChild(callOverlay);

    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        localStream = stream;
        peerConnection = new RTCPeerConnection(config);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = e => {
            let remoteAudio = document.getElementById('remoteAudio');
            if (!remoteAudio) {
                remoteAudio = document.createElement('audio');
                remoteAudio.id = 'remoteAudio';
                remoteAudio.autoplay = true;
                document.body.appendChild(remoteAudio);
            }
            remoteAudio.srcObject = e.streams[0];
        };

        peerConnection.onicecandidate = e => {
            if (e.candidate) {
                socket.send(JSON.stringify({ type: 'ice', candidate: e.candidate, to: partnerInfo.username }));
            }
        };

        if (!isIncoming) {
            peerConnection.createOffer().then(offer => {
                peerConnection.setLocalDescription(offer);
                socket.send(JSON.stringify({ type: 'offer', offer, to: partnerInfo.username, username, avatar: '' }));
            });
        }
    });
}

function acceptCall() {
    const callStatus = document.getElementById('callStatus');
    callStatus.innerText = '已接听，正在建立通话...';
    document.querySelector('#callOverlay audio').pause();

    peerConnection.setRemoteDescription(new RTCSessionDescription(window.incomingOffer)).then(() => {
        peerConnection.createAnswer().then(answer => {
            peerConnection.setLocalDescription(answer);
            socket.send(JSON.stringify({ type: 'answer', answer, to: partnerInfo.username }));
        });
    });
}

function endCall(isCaller = false) {
    if (peerConnection) peerConnection.close();
    if (localStream) localStream.getTracks().forEach(track => track.stop());
    const overlay = document.getElementById('callOverlay');
    if (overlay) overlay.remove();
    isCalling = false;
}
</script>
</body>
</html>
