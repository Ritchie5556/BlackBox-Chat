<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>èŠå¤©å®¤</title>
<style>
  :root {
    --sunset-yellow: #FFD54F;
    --light-red: #FF8A80;
    --warm-orange: #FFB74D;
    --cool-teal: #4DB6AC;
    --light-purple: #BA68C8;
    --light-pink: #F48FB1;
  }
  body {
    margin: 0


      
    font-family: sans-serif;
    background: linear-gradient(135deg, var(--sunset-yellow) 0%, var(--light-red) 20%, var(--warm-orange) 40%, var(--cool-teal) 60%, var(--light-purple) 80%, var(--light-pink) 100%);
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255,255,255,0.2);
    padding: 10px;
    color: #fff;
    font-weight: bold;
    backdrop-filter: blur(5px);
  }
  .top-center {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .top-center img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }
  .top-bar button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
  }
  #log {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }
  .msg {
    max-width: 70%;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 12px;
    color: #000;
    background: rgba(255,255,255,0.8);
    word-wrap: break-word;
  }
  .me { background: #DCF8C6; align-self: flex-end; }
  .other { background: rgba(255,255,255,0.6); align-self: flex-start; }
  .system { background: rgba(200,200,200,0.7); text-align: center; color: #000; }
  .input-area {
    display: flex;
    padding: 10px;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(5px);
    position: relative;
  }
  #msg { flex: 1; padding: 8px; border: none; border-radius: 20px; outline: none; }
  #sendBtn, #emojiBtn { margin-left: 5px; padding: 8px 12px; border: none; border-radius: 20px; cursor: pointer; background: rgba(255,255,255,0.9); }

  /* è¡¨æƒ…é¢æ¿ */
  #emojiPanel {
    position: absolute;
    bottom: 50px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    border-radius: 8px;
    padding: 5px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  #emojiPanel button {
    font-size: 20px;
    border: none;
    background: none;
    cursor: pointer;
  }
  <style>
  /* çŠ¶æ€æ ·å¼ */
  .status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 14px;
    color: #fff;
  }
  .status-circle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: breathe 2s infinite ease-in-out;
  }

  @keyframes breathe {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.6; }
  }

  /* æ ¹æ®ä¸åŒçŠ¶æ€åŠ¨æ€ä¿®æ”¹é¢œè‰²å’ŒåŠ¨ç”»æ—¶é—´ */
  .online { background: green; animation-duration: 2s; }
  .offline { background: gray; animation-duration: 10s; }
  .busy { background: yellow; animation-duration: 15s; }
</style>
</head>
<body>

<div class="top-bar">
  <button onclick="window.location.href='/'">ğŸ </button>
  <div class="top-center">
    <img id="partnerAvatar" src="/image/f64be2438709ee1f11ad8754e282b1df.jpeg" alt="å¯¹æ–¹å¤´åƒ">
    <span id="partnerName">æœªçŸ¥ç”¨æˆ·</span>
    <div id="partnerStatus" class="status">
      <div id="statusCircle" class="status-circle offline"></div>
      <span id="statusText">ç¦»çº¿</span>
  </div>
  </div>
  <button onclick="startCall()">ğŸ“</button>
</div>

<div id="log"></div>

<div class="input-area">
  <input id="msg" placeholder="è¾“å…¥æ¶ˆæ¯..." />
  <button id="emojiBtn" onclick="toggleEmojiPanel()">ğŸ˜Š</button>
  <button id="sendBtn" onclick="send()" disabled>å‘é€</button>
</div>
<script>
</script> 
<script type="module">
  import { schnorr } from "https://esm.sh/@noble/curves/secp256k1";
  import { sha256 } from "https://esm.sh/@noble/hashes/sha256";

  // å·¥å…·å‡½æ•°ï¼šUint8Array â†’ hex
  function toHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }

  // ç”Ÿæˆç§é’¥ã€å…¬é’¥
  const priv = schnorr.utils.randomPrivateKey();
  const pub = schnorr.getPublicKey(priv);

  // æŒ‚åˆ°å…¨å±€ï¼Œåé¢ send() ç”¨
  window.myPrivKey = priv;
  window.myPubKey = toHex(pub);
  window.nobleSchnorr = schnorr;
  console.log("pubkey:", window.myPubKey);
  // === ç”Ÿæˆå‡­è¯ ===
async function generateCredential() {
  const now = Math.floor(Date.now() / 1000); // ç§’çº§æ—¶é—´æˆ³
  const expireAt = now + 7 * 24 * 60 * 60; // +7å¤©

  const payload = {
    pubkey: window.myPubKey,
    issuedAt: now,
    expireAt: expireAt
  };

  // å¯¹ payload åšå“ˆå¸Œ
  const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
  const id = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");

  // ç”¨ schnorr ç­¾å
  const sig = await schnorr.sign(id, window.myPrivKey);

  const credential = {
    ...payload,
    id,
    sig: toHex(sig)
  };

  window.credential = credential; // æŒ‚åˆ°å…¨å±€
  console.log("å‡­è¯ç”Ÿæˆ:", credential);
}
generateCredential();
</script>

<script>
 function toHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }
window.name = "";   
window.onload = () => {
  let name = "";
  do {
    name = prompt("è¯·è¾“å…¥ä½ çš„æ˜µç§°:");
  } while(!name || name.trim() === "");
  window.name = name;  
};
const partnerAvatar = document.getElementById("partnerAvatar");//å¤´åƒ
const partnerName = document.getElementById("partnerName");
const logDiv = document.getElementById("log");
const socket = new WebSocket("wss://relay.damus.io");

let myRoom = null;
let partnerInfo = { name: "æœªçŸ¥ç”¨æˆ·", avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg", online: false };
let emojis = [];
const mysMap = {}; // pubkey â†’ ç”¨æˆ·åæ˜ å°„
//çŠ¶æ€åˆ¤æ–­
function setPartnerStatus(state){
  const circle = document.getElementById("statusCircle");
  const text = document.getElementById("statusText");
  circle.className = "status-circle " + state;
  if(state === "online") {
    text.textContent = "åœ¨çº¿";
    partnerInfo.online = true;
  } else if(state === "offline") {
    text.textContent = "ç¦»çº¿";
    partnerInfo.online = false;
  } else if(state === "busy") {
    text.textContent = "ç¹å¿™";
    partnerInfo.online = true; 
  }
  partnerInfo.state = state;
  console.log("partnerInfo:", partnerInfo); 
}
// -------------------- è¡¨æƒ…åŒ… --------------------
fetch('other/emojis.json')
  .then(res => res.json())
  .then(data => emojis = data);  

function toggleEmojiPanel(){
  let panel = document.getElementById('emojiPanel');
  if(panel) { panel.remove(); return; }

  panel = document.createElement('div');
  panel.id = 'emojiPanel';
  emojis.forEach(e=>{
    const btn = document.createElement('button');
    btn.innerText = e.symbol;
    btn.onclick = ()=> insertEmoji(e.symbol);
    panel.appendChild(btn);
  });
  document.querySelector('.input-area').appendChild(panel);
}

function insertEmoji(symbol){
  const msgInput = document.getElementById("msg");
  msgInput.value += symbol;
  msgInput.focus();
}
async function send(eventobj=null) {
  if (eventobj) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(["EVENT", eventobj]));
      return;
    } else {
      log("âš ï¸ ä¿¡ä»¤å‘é€å¤±è´¥ï¼ŒWebSocketæœªè¿æ¥", "system");
      return;
    }
  }
 if(!eventobj){
   const msgInput = document.getElementById("msg");
   const msg = msgInput.value.trim();
   if (!msg) return;
   if(socket.readyState === WebSocket.OPEN){
   const eventobj = {
    pubkey: window.myPubKey,
    created_at: Math.floor(Date.now() / 1000),
    kind: 1,
    tags: [["t", "room10008"]],   // æŒ‡å®šèŠå¤©å®¤æ ‡ç­¾
    content: msg
    };

   // è®¡ç®— id
   const payload = [0, eventobj.pubkey, eventobj.created_at, eventobj.kind, eventobj.tags, eventobj.content];
   const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
   eventobj.id = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
  // ç­¾å
   const sig = await nobleSchnorr.sign(eventobj.id, window.myPrivKey);
   eventobj.sig = toHex(sig);
  // å‘é€
    socket.send(JSON.stringify(["EVENT", eventobj]));
    if(!eventobj.tags.some(t=>t[0]==="t")){
      document.getElementById("msg").value = "";
       log(`${msg}`, "me"); 
    }
  }  else {
    log("âš ï¸ è¿æ¥å°šæœªå»ºç«‹æˆ–æˆ¿é—´æœªåˆ†é…", "system");
  }
 }
 }
  function announceJoin() {
  // å…ˆæŠŠè‡ªå·±åŠ è¿›åœ¨çº¿åˆ—è¡¨
  participants.push(window.myPubKey);
  console.log("ä½ å·²åŠ å…¥èŠå¤©å®¤ï¼Œå½“å‰äººæ•°ï¼š",  participants.length);

  // å¹¿æ’­ JOIN æ¶ˆæ¯ï¼Œè®©åˆ«äººçŸ¥é“ä½ ä¸Šçº¿äº†
  send({
    pubkey: window.myPubKey,
    created_at: Math.floor(Date.now() / 1000),
    kind: 1,
    tags: [["t", "room10008"], ["status", "JOIN"]],
    content: window.name + " åŠ å…¥äº†èŠå¤©å®¤"
  });
}
// -------------------- èŠå¤©åŠŸèƒ½ --------------------
let participants = [];
socket.onopen = () => {
  log("âœ… å·²è¿æ¥Relayç½‘ç»œèŠå¤©å®¤", "system");
  announceJoin();  // å¹¿æ’­è‡ªå·±ä¸Šçº¿
  setPartnerStatus("online")//åŠ å…¥èŠå¤©å®¤åï¼Œé»˜è®¤åœ¨çº¿çŠ¶æ€
  console.log("å½“å‰çŠ¶æ€:",setPartnerStatus("online"))
  document.getElementById("sendBtn").disabled = false;
  //socket.send(JSON.stringify({ system: true, join: true, name, avatar: "", requestRoom: true }));
  socket.send(
    JSON.stringify(
      [
        "REQ", 
        "sub1",
        { 
          kinds:[1],
          "#t": ["room10008"] 
        }
      ]
    )
  );
  // å‘ä¸€æ¡ system join æ¶ˆæ¯
  const joinEvent = {
    pubkey: window.myPubKey,
    created_at: Math.floor(Date.now() / 1000),
    kind: 1,
    tags: [["t", "room10008"]],
    content:`${window.name} åŠ å…¥äº†èŠå¤©å®¤`
  };
  mysMap[window.myPubKey] = window.name; // ä¿å­˜æ˜ å°„
  participants.push({
    pubkey: window.myPubKey,
    name: window.name,
    avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
    lastSeen: Date.now()
  });
  send(joinEvent);
};
// å®šä¹‰ handleSignal å‡½æ•°
async function handleSignal(data) {
  switch (data.type) {
    case "offer":
      if (!isCalling) {
        await initPeerConnection();
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        ws.send(JSON.stringify({
          type: "answer",
          answer,
          name: window.name
        }));

        alert(`${data.name} å‘èµ·äº†è¯­éŸ³é€šè¯`);
      }
      break;

    case "answer":
      if (peerConnection) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
      }
      break;

    case "ice":
      if (peerConnection && data.candidate) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
      break;

    case "hangup":
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      isCalling = false;
      removeCallOverlay();
      break;
  }
}
function handleEvent(event) {
   const tags = event.tags || [];
   const statusTag = tags.find(t => t[0] === "status");
   if (statusTag) {
     if (statusTag[1] === "JOIN") {
       participants.push(window.myPubKey);
       console.log("ä½ å·²åŠ å…¥èŠå¤©å®¤ï¼Œå½“å‰äººæ•°ï¼š", participants.length);
     } else if (statusTag[1] === "LEAVE") {
       onlines.delete(event.pubkey);
    }
      console.log("å½“å‰èŠå¤©å®¤äººæ•°ï¼š", participants.length);
  }
  const pubkey = event.pubkey;
  const isMe = pubkey === window.myPubKey;
  const name = isMe ? window.name : (myUsersMap[pubkey] || pubkey.slice(0, 8));

  if (event.content.includes("åŠ å…¥äº†èŠå¤©å®¤")) {
    log(`${username} å·²åŠ å…¥æˆ¿é—´`, "system");
    if (!participants.find(p => p.pubkey === pubkey)) {
      participants.push({ pubkey, username, avatar: "xxx", lastSeen: Date.now() });
    }
    return;
  }

  // æ™®é€šæ¶ˆæ¯
  log(`${event.content}`, isMe ? "me" : "other");
  let user = participants.find(p => p.pubkey === pubkey);
  if (user){
    user.lastSeen = Date.now();
  }
  if (!user) {
    user = { pubkey: event.pubkey, name: "æœªçŸ¥ç”¨æˆ·" };
    users.push(user);
    console.log("æ–°ç”¨æˆ·åŠ å…¥ï¼š", user);
  }
   console.log("æ”¶åˆ°æ¶ˆæ¯æ¥è‡ªï¼š", user.pubkey, "å†…å®¹ï¼š", event.content);
}

socket.onmessage = async (e) => {
  try {
    const data = JSON.parse(e.data);
    console.log("æ”¶åˆ°:", e.data);

    // 1. Relay ç¡®è®¤/ç»“æŸæ¶ˆæ¯
    if (Array.isArray(data)) {
      if (data[0] === "OK") {
        console.log("Relayç¡®è®¤:", data);
        return;
      }
      if (data[0] === "EOSE") {
        console.log("EOSE æ”¶åˆ°:", data[1]);
        return;
      }
      if (data[0] === "EVENT") {
        handleEvent(data[2]);  //  èŠå¤©å®¤/äº‹ä»¶æ¶ˆæ¯
        return;
      } 
    }

    // 2. Relay æ¨é€çš„ EVENT
    if (Array.isArray(data) && data[0] === "EVENT") {
      const event = data[2];
      if (!event) return;

      const pubkey = event.pubkey;
      const isMe = pubkey === window.myPubKey;
      const username = isMe ? window.username : (myUsersMap[pubkey] || pubkey.slice(0, 8));

      // å¦‚æœæ˜¯æ–°ç”¨æˆ·ï¼Œå°è¯•ä» content é‡Œæå–ç”¨æˆ·å
      if (!myUsersMap[pubkey]) {
        const match = event.content.match(/^(.+) åŠ å…¥äº†èŠå¤©å®¤$/);
        if (match) {
          myUsersMap[pubkey] = match[1];
        }
      }

      // åŠ å…¥æˆ¿é—´æç¤º
      if (event.content.includes("åŠ å…¥äº†èŠå¤©å®¤")) {
        const joinedName = myUsersMap[pubkey] || "æœªçŸ¥ç”¨æˆ·";
        log(`${joinedName} å·²åŠ å…¥æˆ¿é—´`, "system");

        // æŠŠç”¨æˆ·åŠ å…¥ participants
        if (!participants.find(p => p.pubkey === pubkey)) {
          participants.push({
            pubkey,
            username: joinedName,
            avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
            lastSeen: Date.now()
          });
        }else{
            user.lastSeen = Date.now();
        }
      }

      // æ™®é€šæ¶ˆæ¯
      log(`${event.content}`, isMe ? "me" : "other");

      // æ›´æ–° participants æ´»è·ƒæ—¶é—´
      let user = participants.find(p => p.pubkey === pubkey);
      if (!user) {
        participants.push({
          pubkey,
          username,
          avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
          online: true,  
          lastSeen: Date.now()
        });
      } else {
        user.online = true; 
        user.lastSeen = Date.now();
      }

      // æ›´æ–° partnerInfoï¼ˆåªæ›´æ–°åˆ«äººï¼‰
      if (!isMe) {
        partnerInfo.pubkey = pubkey;
        partnerInfo.username = username;
        partnerInfo.avatar = event.avatar|| "é»˜è®¤å¤´åƒURLæˆ–ç©ºå­—ç¬¦ä¸²";
        partnerInfo.online = true;

        partnerName.textContent = partnerInfo.username;
        partnerAvatar.src = partnerInfo.avatar || partnerAvatar.src;
      }
      if(event.tags?.some(t => t[0] === "call")){
          const signal = JSON.parse(event.content);
         if(signal.type === "offer" && !isCalling){
             window.incomingOffer = { type: signal.offerType, sdp: signal.sdp };
             partnerInfo.username = signal.username;//å¿…é¡»æœ‰sdp
             startCall(true); // è¢«å«
             alert(`${signal.username} å‘èµ·äº†è¯­éŸ³é€šè¯`);
         } else if(signal.type === "answer") {
            peerConnection.setRemoteDescription(new RTCSessionDescription({ type: signal.answerType, sdp: signal.sdp }));
         } else if(signal.type === "ice" && signal.candidate){
           peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
         }
         return;
     }
        return;
    }

    // 3. ç³»ç»Ÿæ¶ˆæ¯ï¼ˆéæ•°ç»„ï¼‰
    if (data.system) {
      log(data.msg, "system");
      return;
    }

    // 4. ä¿¡ä»¤æ¶ˆæ¯ï¼ˆé€šè¯ç”¨ï¼‰
    if (data.type === 'offer' && !isCalling) {
      window.incomingOffer = data.offer;
      partnerInfo.username = data.username;
      partnerName.textContent = partnerInfo.username;
      partnerAvatar.src = data.avatar || partnerAvatar.src;
      startCall(true); // è¢«å«
      return;
    }

    if (data.type === 'answer') {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
      return;
    }

    if (data.type === 'ice' && data.candidate) {
      if (peerConnection) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
      return;
    }
    if (data.type) {
      await handleSignal(data); 
      return;
    }

  } catch (err) {
    console.error("è§£æå¤±è´¥", e.data, err);
    log("è§£æå¤±è´¥: " + e.data, "system");
  }
};

socket.onerror = () => log("âŒ è¿æ¥å‡ºé”™", "system");

function log(message, type="other"){
  const logDiv = document.getElementById("log");
  if(!logDiv) return; 
  const msgDiv = document.createElement("div");
  msgDiv.className = `msg ${type}`;
  msgDiv.textContent = message;
  logDiv.appendChild(msgDiv);
  logDiv.scrollTop = logDiv.scrollHeight;
}

// -------------------- WebRTCè¯­éŸ³é€šè¯ --------------------
let localStream, peerConnection, isCalling = false;
const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
async function initPeerConnection() {
  peerConnection = new RTCPeerConnection(config);

  // è·å–æœ¬åœ°éŸ³é¢‘æµ
  localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

  // æ’­æ”¾è¿œç«¯éŸ³é¢‘
  peerConnection.ontrack = (event) => {
    let remoteAudio = document.getElementById("remoteAudio");
    if (!remoteAudio) {
      remoteAudio = document.createElement("audio");
      remoteAudio.id = "remoteAudio";
      remoteAudio.autoplay = true;
      document.body.appendChild(remoteAudio);
    }
    remoteAudio.srcObject = event.streams[0];
  };

  // å¤„ç† ICE å€™é€‰
  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      send({
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10008"], ["call", "ice"]],
        content: JSON.stringify({ type: "ice", candidate: event.candidate })
      });
    }
  };
}
function getOnlineUsers() {
  return participants.filter(p => p.pubkey !== window.myPubKey && (Date.now() - p.lastSeen) < 60 * 1000);
}
async function startCall(isIncoming = false) {
    console.log("å‘èµ·é€šè¯ï¼ŒisIncoming:", isIncoming);
    console.log("è¿‡æ»¤åçš„å…¶ä»–ç”¨æˆ·:", getOnlineUsers());
   const users = getOnlineUsers();
   console.log("å½“å‰åœ¨çº¿ç”¨æˆ·:",users);
    if (isCalling) return;
    const onlineUsers = getOnlineUsers();
    if (participants.length  === 0) {
        alert("å½“å‰èŠå¤©å®¤æ²¡æœ‰å…¶ä»–åœ¨çº¿ç”¨æˆ·ï¼Œæ— æ³•å‘èµ·é€šè¯");
        return;
    }
    // ç”µè¯èŠå¤©ä¹‹å‰å…ˆåˆ¤æ–­èŠå¤©å®¤é‡Œçš„äººæ•°
    // ä¸´æ—¶è·³è¿‡ç”¨æˆ·æ£€æŸ¥ï¼Œæ–¹ä¾¿è°ƒè¯•
    // if (onlineUsers.length <= 1) {
    //     alert("å½“å‰èŠå¤©å®¤æ²¡æœ‰å…¶ä»–åœ¨çº¿ç”¨æˆ·ï¼Œæ— æ³•å‘èµ·é€šè¯");
    //     return;
    // }

    const now = Math.floor(Date.now() / 1000);
    if (!window.credential || now > window.credential.expireAt) {
        alert("å‡­è¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–");
        return;
    }
    if (!peerConnection || peerConnection.signalingState === "closed") {
        await initPeerConnection();
    }
  const callOverlay = document.createElement('div');
  callOverlay.id = 'callOverlay';
  Object.assign(callOverlay.style,{
    position:'fixed',top:0,left:0,width:'100%',height:'100%',
    background:'rgba(255,255,255,0.2)',backdropFilter:'blur(10px)',
    display:'flex',flexDirection:'column',justifyContent:'center',alignItems:'center',
    zIndex:9999
  });

  const status = document.createElement('div');
  status.id = 'callStatus';
  status.innerText = isIncoming 
  ? `${partnerInfo.username} æ¥ç”µ` 
  : 'æ­£åœ¨ç­‰å¾…å¯¹æ–¹æ¥å¬...';
  Object.assign(status.style,{marginBottom:'20px',color:'#fff',fontSize:'20px'});
  callOverlay.appendChild(status);

  const audio = document.createElement('audio');
  audio.src = 'sound/DaDaDum - The Soundlings.mp3';
  audio.loop = true;
  audio.autoplay = true;
  callOverlay.appendChild(audio);

  const hangupBtn = document.createElement('button');
  hangupBtn.innerText = 'ğŸ“æŒ‚æ–­';
  Object.assign(hangupBtn.style,{background:'red',color:'#fff',marginRight:'20px',padding:'10px 20px'});
  hangupBtn.onclick = () => endCall(true);

  const acceptBtn = document.createElement('button');
  acceptBtn.innerText = 'ğŸ“æ¥å¬';
  Object.assign(acceptBtn.style,{background:'green',color:'#fff',padding:'10px 20px'});
 acceptBtn.onclick = () => acceptCall();

  const btnContainer = document.createElement('div');
  btnContainer.style.display = 'flex';
  btnContainer.style.gap = '20px';
  if(isIncoming) btnContainer.appendChild(acceptBtn);
  btnContainer.appendChild(hangupBtn);
  callOverlay.appendChild(btnContainer);

  document.body.appendChild(callOverlay);
    const callStatus = document.getElementById('callStatus');
    callStatus.innerText = 'æ­£åœ¨å»ºç«‹é€šè¯...';

    isCalling = true;
      // ç¡®ä¿ peerConnection å­˜åœ¨
  if (!peerConnection) await initPeerConnection();

  // æ˜¾ç¤ºé€šè¯çª—å£
  const callUI = document.getElementById("callUI");
  callUI.classList.remove("hidden");
  callUI.classList.add("flex");
  document.getElementById("callStatus").innerText = isIncoming ? "å¯¹æ–¹æ¥ç”µ..." : "æ­£åœ¨å‘¼å«...";

    if (isIncoming) {
        // â€”â€” è¢«å«æµç¨‹ â€”â€” 
        if (window.incomingOffer) {
            await acceptCall();
        }
    } else {
        // â€”â€” ä¸»å«æµç¨‹ â€”â€” 
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        // å‘é€ offer ç»™å¯¹æ–¹
        send({
            pubkey: window.myPubKey,
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            tags: [["t", "room10008"], ["call", "offer"]],
            content: JSON.stringify({ type: 'offer', sdp: offer.sdp, offerType: offer.type, username: window.username })
        });

        log("ğŸ“ å·²å‘é€å‘¼å«è¯·æ±‚", "system");
    }
}
async function acceptCall() {
    if (!peerConnection) {
        await initPeerConnection();
    }
    if (!window.incomingOffer) {
       console.error("æ²¡æœ‰æ”¶åˆ° offerï¼Œæ— æ³•æ¥å¬");
       return;
     }
    const callStatus = document.getElementById('callStatus');
    callStatus.innerText = 'å·²æ¥å¬ï¼Œæ­£åœ¨å»ºç«‹é€šè¯...';
    document.querySelector('#callOverlay audio').pause();

    // è®¾ç½®è¿œç¨‹æè¿°
    await peerConnection.setRemoteDescription(new RTCSessionDescription(window.incomingOffer));

    // åˆ›å»ºå¹¶è®¾ç½®æœ¬åœ°æè¿°ï¼ˆAnswerï¼‰
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);

    // å‘é€ Answer ç»™ä¸»å«
    const answerEvent = {
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now()/1000),
        kind: 1,
        tags: [["t","room10008"], ["call","answer"]],
        content: JSON.stringify({
            type:'answer',
            sdp: answer.sdp,
            answerType: answer.type,
            username: window.username
        })
    };
    // æ›´æ–° UI
    document.getElementById("callStatus").innerText = "é€šè¯ä¸­...";   
}

function endCall(isCaller=false){
  if(peerConnection) {
    peerConnection.close();
    peerConnection = null;
  }
  if(localStream) {
    localStream.getTracks().forEach(track=>track.stop());
    localStream = null;
  }

  // é€šçŸ¥å¯¹æ–¹å‘¼å«å·²å–æ¶ˆ
  if (isCaller && ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "webrtc-hangup",
      from: username
    }));
  }

  const overlay = document.getElementById('callOverlay');
  if(overlay) overlay.remove();
  isCalling = false;
}
</script>

</body>
</html>
