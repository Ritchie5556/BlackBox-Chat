<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>èŠå¤©å®¤</title>
<style>
  :root {
    --sunset-yellow: #FFD54F;
    --light-red: #FF8A80;
    --warm-orange: #FFB74D;
    --cool-teal: #4DB6AC;
    --light-purple: #BA68C8;
    --light-pink: #F48FB1;
  }
  body {
    margin: 0;
    font-family: sans-serif;
    background: linear-gradient(135deg, var(--sunset-yellow) 0%, var(--light-red) 20%, var(--warm-orange) 40%, var(--cool-teal) 60%, var(--light-purple) 80%, var(--light-pink) 100%);
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255,255,255,0.2);
    padding: 10px;
    color: #fff;
    font-weight: bold;
    backdrop-filter: blur(5px);
  }
  .top-center {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .top-center img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
  }
  .top-bar button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
  }
  #log {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }
  .msg {
    max-width: 70%;
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 12px;
    color: #000;
    background: rgba(255,255,255,0.8);
    word-wrap: break-word;
  }
  .me { background: #DCF8C6; align-self: flex-end; }
  .other { background: rgba(255,255,255,0.6); align-self: flex-start; }
  .system { background: rgba(200,200,200,0.7); text-align: center; color: #000; }
  .input-area {
    display: flex;
    padding: 10px;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(5px);
    position: relative;
  }
  #msg { flex: 1; padding: 8px; border: none; border-radius: 20px; outline: none; }
  #sendBtn, #emojiBtn { margin-left: 5px; padding: 8px 12px; border: none; border-radius: 20px; cursor: pointer; background: rgba(255,255,255,0.9); }

  /* è¡¨æƒ…é¢æ¿ */
  #emojiPanel {
    position: absolute;
    bottom: 50px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    border-radius: 8px;
    padding: 5px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  #emojiPanel button {
    font-size: 20px;
    border: none;
    background: none;
    cursor: pointer;
  }
  /* çŠ¶æ€æ ·å¼ */
  .status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 14px;
    color: #fff;
  }
  .status-circle {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    animation: breathe 2s infinite ease-in-out;
  }

  @keyframes breathe {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.6; }
  }

  /* æ ¹æ®ä¸åŒçŠ¶æ€åŠ¨æ€ä¿®æ”¹é¢œè‰²å’ŒåŠ¨ç”»æ—¶é—´ */
  .online { background: green; animation-duration: 2s; }
  .offline { background: gray; animation-duration: 10s; }
  .busy { background: yellow; animation-duration: 15s; }
  
  #callOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  #callStatus {
    margin-bottom: 20px;
    color: #fff;
    font-size: 20px;
  }
  #callTimer {
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    margin: 10px 0;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
  }
</style>
</head>
<body>

<div class="top-bar">
  <button onclick="window.location.href='/'">ğŸ </button>
  <div class="top-center">
    <img id="partnerAvatar" src="/image/f64be2438709ee1f11ad8754e282b1df.jpeg" alt="å¯¹æ–¹å¤´åƒ">
    <span id="partnerName">æœªçŸ¥ç”¨æˆ·</span>
    <div id="partnerStatus" class="status">
      <div id="statusCircle" class="status-circle offline"></div>
      <span id="statusText">ç¦»çº¿</span>
    </div>
  </div>
  <button onclick="startCall()">ğŸ“</button>
</div>

<div id="log"></div>

<div class="input-area">
  <input id="msg" placeholder="è¾“å…¥æ¶ˆæ¯..." />
  <button id="emojiBtn" onclick="toggleEmojiPanel()">ğŸ˜Š</button>
  <button id="sendBtn" onclick="send()" disabled>å‘é€</button>
</div>

<!-- é€šè¯æµ®å±‚ -->
<div id="callUI" class="hidden"></div>

<script type="module">
import { secp256k1 } from 'https://esm.sh/@noble/curves/secp256k1';
import { schnorr } from 'https://esm.sh/@noble/curves/secp256k1'; 
// ç”Ÿæˆç§é’¥å¹¶è®¡ç®—å…¬é’¥
const priv = new Uint8Array(32);
crypto.getRandomValues(priv);
console.log(priv); 
const pub = secp256k1.getPublicKey(priv);
  // === ç”Ÿæˆå‡­è¯ ===
  async function generateCredential() {
    const now = Math.floor(Date.now() / 1000); // ç§’çº§æ—¶é—´æˆ³
    const expireAt = now + 7 * 24 * 60 * 60; // +7å¤©
    const payload = {
      pubkey: window.myPubKey,
      issuedAt: now,
      expireAt: expireAt
    };

    const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(JSON.stringify(payload)));
    const id = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    const sig = await schnorr.sign(id, window.myPrivKey);

    const credential = {
      ...payload,
      id,
      sig: toHex(sig)
    };

    window.credential = credential; // æŒ‚åˆ°å…¨å±€
    console.log("å‡­è¯ç”Ÿæˆ:", credential);
  }
  
  generateCredential();

  function toHex(bytes) {
    console.log("ä¼ å…¥æœ‰æ•ˆå‚æ•°:",bytes)
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }
  
  const partnerAvatar = document.getElementById("partnerAvatar");//å¤´åƒ
  const partnerName = document.getElementById("partnerName");
  const logDiv = document.getElementById("log");
  const socket = new WebSocket("wss://relay.damus.io");
  window.myPubKey = toHex(pub);
  console.log("pubkey:", window.myPubKey);
  window.name = "";   
  window.onload = () => {
    let name = "";
    do {
      name = prompt("è¯·è¾“å…¥ä½ çš„æ˜µç§°:");
    } while(!name || name.trim() === "");
    window.name = name;  
  };
  
  let myRoom = null;
  let partnerInfo = { name: "æœªçŸ¥ç”¨æˆ·", avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg", online: false };
  let emojis = [];
  const mysMap = {}; // pubkey â†’ ç”¨æˆ·åæ˜ å°„
  // å…¨å±€å˜é‡ç”¨äºå­˜å‚¨è®¡æ—¶å™¨
  let callTimerInterval = null;
  let callStartTime = null;
  
  //çŠ¶æ€åˆ¤æ–­
  function setPartnerStatus(state){
    const circle = document.getElementById("statusCircle");
    const text = document.getElementById("statusText");
    circle.className = "status-circle " + state;
    if(state === "online") {
      text.textContent = "åœ¨çº¿";
      partnerInfo.online = true;
    } else if(state === "offline") {
      text.textContent = "ç¦»çº¿";
      partnerInfo.online = false;
    } else if(state === "busy") {
      text.textContent = "ç¹å¿™";
      partnerInfo.online = true; 
    }
    partnerInfo.state = state;
    console.log("partnerInfo:", partnerInfo); 
  }
  
  // -------------------- è¡¨æƒ…åŒ… --------------------
  function toggleEmojiPanel(){
    let panel = document.getElementById('emojiPanel');
    if(panel) { panel.remove(); return; }
    
    fetch('other/emojis.json')
      .then(res => res.json())
      .then(data => emojis = data);  

    panel = document.createElement('div');
    panel.id = 'emojiPanel';
    emojis.forEach(e=>{
      const btn = document.createElement('button');
      btn.innerText = e.symbol;
      btn.onclick = ()=> insertEmoji(e.symbol);
      panel.appendChild(btn);
    });
    document.querySelector('.input-area').appendChild(panel);
  }

  function insertEmoji(symbol){
    const msgInput = document.getElementById("msg");
    msgInput.value += symbol;
    msgInput.focus();
  }
  
async function send(eventobj=null) {
  if (eventobj) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(["EVENT", eventobj]));
      return;
    } else {
      log("ä¿¡ä»¤å‘é€å¤±è´¥ï¼ŒWebSocketæœªè¿æ¥", "system");
      return;
    }
  }

  if (!eventobj) {
    const msgInput = document.getElementById("msg");
    const msg = msgInput.value.trim();
    if (!msg) return;

    if (socket.readyState === WebSocket.OPEN) {
      const eventobj = {
        id: "",
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10011"]],
        content: msg
      };

      // è®¡ç®— id
      const payload = [0, eventobj.pubkey, eventobj.created_at, eventobj.kind, eventobj.tags, eventobj.content];
      const serialized = JSON.stringify(payload);
      const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized));
      const uint8Hash = new Uint8Array(hash);
      eventobj.id = toHex(uint8Hash);  // è½¬æ¢æˆåå…­è¿›åˆ¶å­—ç¬¦ä¸²
      console.log("idæ‰“å°å‡º:", eventobj.id);

      // ç­¾å
      const sig = await nobleSchnorr.sign(uint8Hash, window.myPrivKey);  // åªç­¾åä¸€æ¬¡
      eventobj.sig = toHex(sig);  // å°†ç­¾åè½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²

      // å‘é€
      socket.send(JSON.stringify(["EVENT", eventobj]));
      
      if (!eventobj.tags.some(t => t[0] === "t")) {
        document.getElementById("msg").value = "";
        log(`${msg}`, "me");
      }
    } else {
      log("âš ï¸ è¿æ¥å°šæœªå»ºç«‹æˆ–æˆ¿é—´æœªåˆ†é…", "system");
    }
  }
}
  // ç¡®ä¿ DOM åŠ è½½åå†ç»‘å®šäº‹ä»¶
  window.addEventListener("DOMContentLoaded", () => {
    const sendBtn = document.getElementById("sendBtn");
    sendBtn.addEventListener("click", () => send());
  });
  
  function announceJoin(sername, pubkey, avatar) {
    // å…ˆæŠŠè‡ªå·±åŠ è¿›åœ¨çº¿åˆ—è¡¨
    participants.push({
      pubkey: window.myPubKey,
      username: window.name,
      avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
      lastSeen: Date.now()
    });
    console.log("ä½ å·²åŠ å…¥èŠå¤©å®¤ï¼Œå½“å‰äººæ•°ï¼š",  participants.length);

    // å¹¿æ’­ JOIN æ¶ˆæ¯ï¼Œè®©åˆ«äººçŸ¥é“ä½ ä¸Šçº¿äº†
    send({
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10011"], ["status", "JOIN"]],
      content: window.name + " åŠ å…¥äº†èŠå¤©å®¤"
    });
  }
  
  // å®šä¹‰ handleSignal å‡½æ•°
  async function handleSignal(data) {
    switch (data.type) {
      case "offer":
        if (!isCalling) {
          await initPeerConnection();
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          socket.send(JSON.stringify({
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            tags: [["t", "room10011"], ["call", "answer"]],
            content: JSON.stringify({
              type: "answer",
              answer: answer,
              name: window.name
            })
          }));
          alert(`${data.name} å‘èµ·äº†è¯­éŸ³é€šè¯`);
        }
        break;

      case "answer":
        if (peerConnection) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
        break;

      case "ice":
        if (peerConnection && data.candidate) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
        break;

      case "hangup":
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
        isCalling = false;
        removeCallOverlay();
        break;
    }
  }
  
  // ç”¨æˆ·ç®¡ç†é€»è¾‘
  function handleEvent(event) {
    const tags = event.tags || [];
    const statusTag = tags.find(t => t[0] === "status");
    const pubkey = event.pubkey;
    const isMe = pubkey === window.myPubKey;

    // è·å–æˆ–åˆ›å»ºç”¨æˆ·ä¿¡æ¯
    let user = participants.find(p => p.pubkey === pubkey);
    if (!user) {
      user = {
        pubkey: pubkey,
        username: isMe ? window.name : pubkey.slice(0, 8),
        avatar: "https://robohash.org/" + pubkey,
        lastSeen: Date.now()
      };
      participants.push(user);
    } else {
      user.lastSeen = Date.now();
    }

    // å¤„ç†çŠ¶æ€æ ‡ç­¾
    if (statusTag) {
      if (statusTag[1] === "JOIN") {
        log(`${user.username} åŠ å…¥äº†èŠå¤©å®¤`, "system");
      } else if (statusTag[1] === "LEAVE") {
        participants = participants.filter(p => p.pubkey !== pubkey);
        log(`${user.username} ç¦»å¼€äº†èŠå¤©å®¤`, "system");
        return;
      }
    }
    
    // å¤„ç†æ™®é€šæ¶ˆæ¯
    if (event.content && !event.content.includes("åŠ å…¥äº†èŠå¤©å®¤") && !event.content.includes("ç¦»å¼€äº†èŠå¤©å®¤")) {
      log(`${user.username}: ${event.content}`, isMe ? "me" : "other");
    }
    
    // æ›´æ–°partnerInfoï¼ˆå¦‚æœæ˜¯å¯¹æ–¹ï¼‰
    if (!isMe) {
      partnerInfo.pubkey = pubkey;
      partnerInfo.username = user.username;
      partnerInfo.avatar = user.avatar;
      partnerInfo.online = true;
      
      partnerName.textContent = partnerInfo.username;
      partnerAvatar.src = partnerInfo.avatar;
      setPartnerStatus("online");
    }
  }

  let participants = [];
  socket.onopen = () => {
    log("âœ… å·²è¿æ¥Relayç½‘ç»œèŠå¤©å®¤", "system");
    announceJoin();  // å¹¿æ’­è‡ªå·±ä¸Šçº¿
    setPartnerStatus("online");//åŠ å…¥èŠå¤©å®¤åï¼Œé»˜è®¤åœ¨çº¿çŠ¶æ€
    console.log("å½“å‰çŠ¶æ€:", setPartnerStatus("online"));
    document.getElementById("sendBtn").disabled = false;
    
    socket.send(
      JSON.stringify(
        [
          "REQ", 
          "sub1",
          { 
            kinds:[1],
            "#t": ["room10011"] 
          }
        ]
      )
    );
    
    // å‘ä¸€æ¡ system join æ¶ˆæ¯
    const joinEvent = {
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10011"]],
      content: `${window.name} åŠ å…¥äº†èŠå¤©å®¤`
    };
    
    mysMap[window.myPubKey] = window.name; // ä¿å­˜æ˜ å°„
    participants.push({
      pubkey: window.myPubKey,
      name: window.name,
      avatar: "/image/f64be2438709ee1f11ad8754e282b1df.jpeg",
      lastSeen: Date.now()
    });
    
    send(joinEvent);
  };
  
  socket.onmessage = async (e) => {
    try {
      const data = JSON.parse(e.data);
      console.log("æ”¶åˆ°:", e.data);
      
      // 1. å¤„ç†æ•°ç»„æ ¼å¼çš„æ¶ˆæ¯ (Nostråè®®æ ‡å‡†æ ¼å¼)
      if (Array.isArray(data)) {
        if (data[0] === "OK") {
          console.log("Relayç¡®è®¤:", data);
          return;
        }
        
        if (data[0] === "EOSE") {
          console.log("EOSE æ”¶åˆ°:", data[1]);
          return;
        }
        
        if (data[0] === "EVENT") {
          const event = data[2];
          if (!event || !event.pubkey) return;
          
          // æ›´æ–°ç”¨æˆ·æ˜ å°„
          if (!mysMap[event.pubkey]) {
            mysMap[event.pubkey] = event.username || event.pubkey.slice(0, 8); 
          }
          
          console.log("å½“å‰åœ¨çº¿ç”¨æˆ·:", Object.values(mysMap));
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯é€šè¯ç›¸å…³äº‹ä»¶
          const callTag = event.tags?.find(t => t[0] === "call");
          if (callTag) {
            try {
              const signal = JSON.parse(event.content);
              // åªå¤„ç†æ¥è‡ªå¯¹æ–¹çš„æ¶ˆæ¯ï¼ˆæ’é™¤è‡ªå·±å‘é€çš„æ¶ˆæ¯ï¼‰
              if (event.pubkey === window.myPubKey) {
                console.log("å¿½ç•¥è‡ªå·±å‘é€çš„ä¿¡ä»¤æ¶ˆæ¯");
                return;
              }
              
              // å¤„ç†æ¥ç”µ
              if (callTag[1] === "offer" && !isCalling) {
                window.incomingOffer = { type: "offer", sdp: signal.sdp };
                partnerInfo.username = signal.username || "æœªçŸ¥ç”¨æˆ·";
                partnerName.textContent = partnerInfo.username;
                
                // æ˜¾ç¤ºæ¥ç”µç•Œé¢
                showCallOverlay(true); // æ˜¾ç¤ºè¢«å«ç•Œé¢
                alert(`${partnerInfo.username} å‘èµ·äº†è¯­éŸ³é€šè¯`);
                return;
              }
              
              // å¤„ç†å…¶ä»–ä¿¡ä»¤ï¼ˆanswerã€iceç­‰ï¼‰
              if (peerConnection) {
                console.log("å¤„ç†ä¿¡ä»¤:", callTag[1], "å½“å‰çŠ¶æ€:", peerConnection.signalingState);
                
                if (callTag[1] === "answer") {
                  console.log("è®¾ç½®è¿œç¨‹answer");
                  await peerConnection.setRemoteDescription(
                    new RTCSessionDescription({
                      type: "answer",
                      sdp: signal.sdp
                    })
                  );
                } else if (callTag[1] === "ice") {
                  if (peerConnection.remoteDescription) {
                    console.log("æ·»åŠ ICEå€™é€‰");
                    await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                  } else {
                    console.log("ç¼“å­˜ICEå€™é€‰ï¼Œç­‰å¾…è¿œç¨‹æè¿°");
                    // å¯ä»¥ç¼“å­˜ICEå€™é€‰ï¼Œç­‰åˆ°æœ‰è¿œç¨‹æè¿°åå†æ·»åŠ 
                  }
                } else if (callTag[1] === "hangup") {
                  console.log("æ”¶åˆ°æŒ‚æ–­ä¿¡ä»¤");
                  endCall(false);
                }
              }
              return;
            } catch (err) {
              console.error("è§£æé€šè¯ä¿¡ä»¤å¤±è´¥", err);
            }
            return;
          }
          
          // å¤„ç†æ™®é€šäº‹ä»¶
          handleEvent(event);
          return;
        }
      }
      
      // 2. å¤„ç†éæ ‡å‡†æ ¼å¼çš„æ¶ˆæ¯ï¼ˆç³»ç»Ÿæ¶ˆæ¯å’Œæ—§ç‰ˆä¿¡ä»¤ï¼‰
      if (data.system) {
        log(data.msg, "system");
        return;
      }
      
      // å¤„ç†æ—§ç‰ˆä¿¡ä»¤æ ¼å¼ï¼ˆåº”è¯¥é€æ­¥è¿ç§»åˆ°ä½¿ç”¨Nosträº‹ä»¶çš„æ ‡å‡†æ ¼å¼ï¼‰
      if (data.type === 'offer' && !isCalling) {
        window.incomingOffer = data.offer;
        partnerInfo.username = data.username;
        partnerName.textContent = partnerInfo.username;
        partnerAvatar.src = data.avatar || partnerAvatar.src;
        startCall(true);
        return;
      }
      
      if (data.type === 'answer') {
        if (peerConnection) {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(
              data.answer
            )
          );
        }
        return;
      }
      
      if (data.type === 'ice' && data.candidate) {
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
        return;
      }
      
      if (data.type) {
        await handleSignal(data);
        return;
      }
      
    } catch (err) {
      console.error("è§£æå¤±è´¥", e.data, err);
      log("è§£æå¤±è´¥: " + e.data, "system");
    }
  };
  
  socket.onerror = () => log("âŒ è¿æ¥å‡ºé”™", "system");

  function log(message, type="other"){
    const logDiv = document.getElementById("log");
    if(!logDiv) return; 
    const msgDiv = document.createElement("div");
    msgDiv.className = `msg ${type}`;
    msgDiv.textContent = message;
    logDiv.appendChild(msgDiv);
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // -------------------- WebRTCè¯­éŸ³é€šè¯ --------------------
  let localStream, peerConnection, isCalling = false;
  const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  
  async function initPeerConnection() {
    try {
      // å¦‚æœå·²å­˜åœ¨PeerConnectionï¼Œå…ˆå…³é—­å®ƒ
      if (peerConnection) {
        peerConnection.close();
      }
      
      peerConnection = new RTCPeerConnection(config);
      
      // æ·»åŠ çŠ¶æ€ç›‘å¬
      peerConnection.onconnectionstatechange = () => {
        console.log("è¿æ¥çŠ¶æ€å˜åŒ–:", peerConnection.connectionState);
      };
      
      peerConnection.onsignalingstatechange = () => {
        console.log("ä¿¡ä»¤çŠ¶æ€å˜åŒ–:", peerConnection.signalingState);
      };
      
      peerConnection.oniceconnectionstatechange = () => {
        console.log("ICEè¿æ¥çŠ¶æ€å˜åŒ–:", peerConnection.iceConnectionState);
      };
      
      peerConnection.onicegatheringstatechange = () => {
        console.log("ICEæ”¶é›†çŠ¶æ€å˜åŒ–:", peerConnection.iceGatheringState);
      };

      // è·å–æœ¬åœ°éŸ³é¢‘æµ
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      // æ’­æ”¾è¿œç«¯éŸ³é¢‘
      peerConnection.ontrack = (event) => {
        console.log("æ”¶åˆ°è¿œç«¯éŸ³è½¨");
        let remoteAudio = document.getElementById("remoteAudio");
        if (!remoteAudio) {
          remoteAudio = document.createElement("audio");
          remoteAudio.id = "remoteAudio";
          remoteAudio.autoplay = true;
          document.body.appendChild(remoteAudio);
        }
        remoteAudio.srcObject = event.streams[0];
      };

      // å¤„ç† ICE å€™é€‰
      peerConnection.onicecandidate = async (event) => {
        if (event.candidate) {
          console.log("ç”ŸæˆICEå€™é€‰");
          const iceEvent = {
            pubkey: window.myPubKey,
            created_at: Math.floor(Date.now() / 1000),
            kind: 1,
            tags: [["t", "room10011"], ["call", "ice"]],
            content: JSON.stringify({ 
              type: "ice", 
              candidate: event.candidate 
            })
          };
          
          // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
          const payload = [0, iceEvent.pubkey, iceEvent.created_at, iceEvent.kind, iceEvent.tags, iceEvent.content];
          const serialized = JSON.stringify(payload);
          const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized));
          iceEvent.id = toHex(new Uint8Array(hash));
          const sig = await nobleSchnorr.sign(iceEvent.id, window.myPrivKey);
          iceEvent.sig = toHex(sig);
          
          // å‘é€ICEå€™é€‰äº‹ä»¶
          socket.send(JSON.stringify(["EVENT", iceEvent]));
        } else {
          console.log("ICEå€™é€‰æ”¶é›†å®Œæˆ");
        }
      };
      
    } catch (err) {
      console.error("åˆå§‹åŒ–PeerConnectionå¤±è´¥", err);
      alert("åˆå§‹åŒ–è¯­éŸ³é€šè¯å¤±è´¥: " + err.message);
      endCall(true);
    }
  }
  
  // æ·»åŠ ä¸€ä¸ªå‡½æ•°æ¥æ£€æŸ¥å¹¶æ¢å¤PeerConnectionçŠ¶æ€
  function checkAndResetPeerConnection() {
    if (peerConnection) {
      const state = peerConnection.signalingState;
      console.log("å½“å‰PeerConnectionçŠ¶æ€:", state);
      
      // å¦‚æœçŠ¶æ€ä¸æ˜¯stableï¼Œå¯èƒ½éœ€è¦é‡ç½®
      if (state !== "stable") {
        console.log("é‡ç½®PeerConnection");
        peerConnection.close();
        peerConnection = null;
        return false;
      }
    }
    return true;
  }
  
  function getOnlineUsers() {
    return participants.filter(
      p => p.pubkey !== window.myPubKey && (Date.now() - p.lastSeen) < 10*60 * 1000
    );
  }
  
  async function startCall(isIncoming = false) {
    console.log("å‘èµ·é€šè¯ï¼ŒisIncoming:", isIncoming);
    // æ£€æŸ¥å¹¶é‡ç½®PeerConnectionçŠ¶æ€
    if (!checkAndResetPeerConnection()) {
      console.log("PeerConnectionçŠ¶æ€å¼‚å¸¸ï¼Œå·²é‡ç½®");
    }

    // æ£€æŸ¥åœ¨çº¿ç”¨æˆ·
    const onlineUsers = participants.filter(
      p => p.pubkey !== window.myPubKey && (Date.now() - p.lastSeen) < 100 * 60 * 1000
    );
    console.log("å½“å‰åœ¨çº¿ç”¨æˆ·:", onlineUsers);
    
    if (onlineUsers.length === 0) {
      alert("å½“å‰èŠå¤©å®¤æ²¡æœ‰å…¶ä»–åœ¨çº¿ç”¨æˆ·ï¼Œæ— æ³•å‘èµ·é€šè¯");
      return;
    }

    const now = Math.floor(Date.now() / 1000);
    if (!window.credential || now > window.credential.expireAt) {
      alert("å‡­è¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–");
      return;
    }

    // ç¡®ä¿ peerConnection å­˜åœ¨
    if (!peerConnection || peerConnection.signalingState === "closed") {
      await initPeerConnection();
    }

    // å¦‚æœæ˜¯ä¸»å«æ–¹ï¼ˆå‘èµ·é€šè¯ï¼‰
    if (!isIncoming) {
      // åˆ›å»ºå¹¶å‘é€offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      
      // åˆ›å»ºé€šè¯äº‹ä»¶
      const callEvent = {
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10011"], ["call", "offer"]],
        content: JSON.stringify({
          type: "offer",
          sdp: offer.sdp,
          username: window.name
        })
      };
      
      // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
      const payload = [0, callEvent.pubkey, callEvent.created_at, callEvent.kind, callEvent.tags, callEvent.content];
      const serialized = JSON.stringify(payload);
      const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized));
      callEvent.id = toHex(new Uint8Array(hash));
      const sig = await nobleSchnorr.sign(callEvent.id, window.myPrivKey);
      callEvent.sig = toHex(sig);
      
      // å‘é€é€šè¯äº‹ä»¶
      socket.send(JSON.stringify(["EVENT", callEvent]));
      log("ğŸ“ å·²å‘é€å‘¼å«è¯·æ±‚", "system");
    }

    // æ˜¾ç¤ºé€šè¯ç•Œé¢
    showCallOverlay(isIncoming);
    isCalling = true;
  }
  
  // æ˜¾ç¤ºé€šè¯ç•Œé¢çš„å‡½æ•°
  function showCallOverlay(isIncoming) {
    // ç§»é™¤å·²å­˜åœ¨çš„é€šè¯ç•Œé¢ï¼ˆå¦‚æœæœ‰ï¼‰
    const existingOverlay = document.getElementById('callOverlay');
    if (existingOverlay) {
      existingOverlay.remove();
    }
    
    const callOverlay = document.createElement('div');
    callOverlay.id = 'callOverlay';
    Object.assign(callOverlay.style, {
      position: 'fixed', 
      top: 0, 
      left: 0, 
      width: '100%', 
      height: '100%',
      background: 'rgba(255,255,255,0.2)', 
      backdropFilter: 'blur(10px)',
      display: 'flex', 
      flexDirection: 'column', 
      justifyContent: 'center', 
      alignItems: 'center',
      zIndex: 9999
    });

    const status = document.createElement('div');
    status.id = 'callStatus';
    status.innerText = isIncoming 
      ? `${partnerInfo.username} æ¥ç”µ` 
      : 'æ­£åœ¨ç­‰å¾…å¯¹æ–¹æ¥å¬...';
    Object.assign(status.style, {
      marginBottom: '20px', 
      color: '#fff', 
      fontSize: '20px'
    });
    callOverlay.appendChild(status);
    
    // æ·»åŠ é€šè¯è®¡æ—¶å™¨
    const timer = document.createElement('div');
    timer.id = 'callTimer';
    timer.innerText = '00:00:00';
    Object.assign(timer.style, {
      marginBottom: '20px', 
      color: '#fff', 
      fontSize: '24px',
      fontWeight: 'bold'
    });
    callOverlay.appendChild(timer);
    
    // åªåœ¨ä¸»å«æ–¹æ’­æ”¾é“ƒå£°
    if (!isIncoming) {
      const audio = document.createElement('audio');
      audio.src = 'sound/DaDaDum - The Soundlings.mp3';
      audio.loop = true;
      audio.autoplay = true;
      callOverlay.appendChild(audio);
    }

    const hangupBtn = document.createElement('button');
    hangupBtn.innerText = 'ğŸ“æŒ‚æ–­';
    Object.assign(hangupBtn.style, {
      background: 'red', 
      color: '#fff', 
      marginRight: '20px', 
      padding: '10px 20px'
    });
    hangupBtn.onclick = () => endCall(true);

    const acceptBtn = document.createElement('button');
    acceptBtn.innerText = 'ğŸ“æ¥å¬';
    Object.assign(acceptBtn.style, {
      background: 'green', 
      color: '#fff', 
      padding: '10px 20px'
    });
    acceptBtn.onclick = () => acceptCall();

    const btnContainer = document.createElement('div');
    btnContainer.style.display = 'flex';
    btnContainer.style.gap = '20px';
    if (isIncoming) btnContainer.appendChild(acceptBtn);
    btnContainer.appendChild(hangupBtn);
    callOverlay.appendChild(btnContainer);

    document.body.appendChild(callOverlay);
  }
  
  // å¯åŠ¨é€šè¯è®¡æ—¶å™¨
  function startCallTimer() {
    // æ¸…é™¤ç°æœ‰çš„è®¡æ—¶å™¨ï¼ˆå¦‚æœæœ‰ï¼‰
    if (callTimerInterval) {
      clearInterval(callTimerInterval);
    }
    
    // è®°å½•é€šè¯å¼€å§‹æ—¶é—´
    callStartTime = new Date();
    
    // æ›´æ–°è®¡æ—¶å™¨æ˜¾ç¤º
    updateCallTimer();
    
    // æ¯ç§’æ›´æ–°ä¸€æ¬¡è®¡æ—¶å™¨
    callTimerInterval = setInterval(updateCallTimer, 1000);
  }
  
  // æ›´æ–°é€šè¯è®¡æ—¶å™¨æ˜¾ç¤º
  function updateCallTimer() {
    const timerElement = document.getElementById('callTimer');
    if (!timerElement) return;
    
    // è®¡ç®—é€šè¯æ—¶é•¿ï¼ˆç§’ï¼‰
    const now = new Date();
    const elapsedSeconds = Math.floor((now - callStartTime) / 1000);
    
    // æ ¼å¼åŒ–ä¸ºHH:MM:SS
    const hours = Math.floor(elapsedSeconds / 3600);
    const minutes = Math.floor((elapsedSeconds % 3600) / 60);
    const seconds = elapsedSeconds % 60;
    
    // æ›´æ–°æ˜¾ç¤º
    timerElement.innerText = 
      `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }
  
  // åœæ­¢é€šè¯è®¡æ—¶å™¨
  function stopCallTimer() {
    if (callTimerInterval) {
      clearInterval(callTimerInterval);
      callTimerInterval = null;
    }
    
    // é‡ç½®è®¡æ—¶å™¨æ˜¾ç¤º
    const timerElement = document.getElementById('callTimer');
    if (timerElement) {
      timerElement.innerText = '00:00:00';
    }
  }
  
  async function acceptCall() {
    if (!peerConnection) {
      await initPeerConnection();
    }
    
    if (!window.incomingOffer) {
      console.error("æ²¡æœ‰æ”¶åˆ° offerï¼Œæ— æ³•æ¥å¬");
      return;
    }
    
    // æ›´æ–°ç•Œé¢çŠ¶æ€
    const callStatus = document.getElementById('callStatus');
    if (callStatus) {
      callStatus.innerText = 'å·²æ¥å¬ï¼Œæ­£åœ¨å»ºç«‹é€šè¯...';
    }
    
    // åœæ­¢é“ƒå£°ï¼ˆå¦‚æœæœ‰ï¼‰
    const audio = document.querySelector('#callOverlay audio');
    if (audio) {
      audio.pause();
    }

    // è®¾ç½®è¿œç¨‹æè¿°
    await peerConnection.setRemoteDescription(new RTCSessionDescription(window.incomingOffer));

    // åˆ›å»ºå¹¶è®¾ç½®æœ¬åœ°æè¿°ï¼ˆAnswerï¼‰
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);

    // å‘é€ Answer ç»™ä¸»å«
    const answerEvent = {
      pubkey: window.myPubKey,
      created_at: Math.floor(Date.now() / 1000),
      kind: 1,
      tags: [["t", "room10011"], ["call", "answer"]],
      content: JSON.stringify({
        type: 'answer',
        sdp: answer.sdp,
        username: window.name
      })
    };
    
    // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
    const payload = [0, answerEvent.pubkey, answerEvent.created_at, answerEvent.kind, answerEvent.tags, answerEvent.content];
    const serialized = JSON.stringify(payload);
    const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized));
    answerEvent.id = toHex(new Uint8Array(hash));
    const sig = await nobleSchnorr.sign(answerEvent.id, window.myPrivKey);
    answerEvent.sig = toHex(sig);

    // å‘é€åº”ç­”äº‹ä»¶
    socket.send(JSON.stringify(["EVENT", answerEvent]));
    
    // å¯åŠ¨é€šè¯è®¡æ—¶å™¨
    startCallTimer();
    
    // æ›´æ–° UI
    if (callStatus) {
      callStatus.innerText = "é€šè¯ä¸­...";
    }
  }
  
  async function endCall(isCaller = false) {
    console.log("ç»“æŸé€šè¯ï¼ŒisCaller:", isCaller);
    // åœæ­¢é€šè¯è®¡æ—¶å™¨
    stopCallTimer();
    
    // å‘é€æŒ‚æ–­ä¿¡ä»¤
    if (isCaller && socket && socket.readyState === WebSocket.OPEN) {
      const hangupEvent = {
        pubkey: window.myPubKey,
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [["t", "room10011"], ["call", "hangup"]],
        content: JSON.stringify({
          type: "hangup"
        })
      };
      
      // è®¡ç®—äº‹ä»¶IDå’Œç­¾å
      const payload = [0, hangupEvent.pubkey, hangupEvent.created_at, hangupEvent.kind, hangupEvent.tags, hangupEvent.content];
      const serialized = JSON.stringify(payload);
      const hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(serialized));
      hangupEvent.id = toHex(new Uint8Array(hash));
      const sig = await nobleSchnorr.sign(hangupEvent.id, window.myPrivKey);
      hangupEvent.sig = toHex(sig);
      
      socket.send(JSON.stringify(["EVENT", hangupEvent]));
    }
    
    // å…³é—­PeerConnection
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    
    // åœæ­¢æœ¬åœ°æµ
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    
    // ç§»é™¤é€šè¯ç•Œé¢
    const overlay = document.getElementById('callOverlay');
    if (overlay) {
      overlay.remove();
    }
    
    // ç§»é™¤è¿œç«¯éŸ³é¢‘å…ƒç´ 
    const remoteAudio = document.getElementById("remoteAudio");
    if (remoteAudio) {
      remoteAudio.remove();
    }
    
    isCalling = false;
    window.incomingOffer = null;
    
    log("é€šè¯å·²ç»“æŸ", "system");
  }
</script>
</body>
</html>
